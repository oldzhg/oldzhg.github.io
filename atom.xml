<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>白驹过隙</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.oldzhg.com/"/>
  <updated>2022-10-08T11:36:28.721Z</updated>
  <id>https://www.oldzhg.com/</id>
  
  <author>
    <name>Old zhg</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mac 微信备份到外接硬盘方案</title>
    <link href="https://www.oldzhg.com/2022/10/08/WeChat-backs-up-to-an-external-hard-disk-on-Mac/"/>
    <id>https://www.oldzhg.com/2022/10/08/WeChat-backs-up-to-an-external-hard-disk-on-Mac/</id>
    <published>2022-10-08T08:22:45.000Z</published>
    <updated>2022-10-08T11:36:28.721Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>mac版本微信中并没有指定备份路径的功能，备份的聊天记录文件也在一个很难找的位置。对于使用256g硬盘的mac的用户，微信聊天记录动辄十几G、几十G的大小，会造成非常严重的硬盘容量恐慌。所以把微信备份文件迁移到外置硬盘是一件非常有意义的工作。</p></blockquote><h2 id="微信的备份路径"><a href="#微信的备份路径" class="headerlink" title="微信的备份路径"></a>微信的备份路径</h2><p>微信的备份在</p><p><code>~/Library/Containers/com.tencent.xinWeChat/Data/Library/Application\ Support/com.tencent.xinWeChat/2.0b4.0.9</code> 这个目录下面的 <code>Backup</code> 文件夹里面。</p><p><img src="https://pic.oldzhg.com/uPic/image-1663224431683.webp" alt="image-1663224431683"></p><p>每一个微信账号的聊天记录备份对应这个目录下的一个文件夹（名称为一长串的字母及数字)</p><h2 id="比较简单的迁移方式"><a href="#比较简单的迁移方式" class="headerlink" title="比较简单的迁移方式"></a>比较简单的迁移方式</h2><p>知道了文件备份在那个目录，其实我们只需要每次备份完成之后，把这个里面的文件夹剪切粘贴到移动硬盘的指定位置即可。<br>需要恢复备份的时候再从移动硬盘里面把文件拷贝回这个目录即可。</p><h2 id="更智能的迁移方式"><a href="#更智能的迁移方式" class="headerlink" title="更智能的迁移方式"></a>更智能的迁移方式</h2><p>前一种方式操作起来稍微有点麻烦，需要自己来回复制，怎么才能省略掉这两个手动复制粘贴的操作呢，答案就是使用软连接的方式。</p><ul><li>如果你的mac版微信没有执行过备份操作，那可能没有这个Backup目录，或者Backup目录下面没有子目录，为了保证文件权限一致，需要先执行一次备份生成这个目录（无需全量备份，只备份一个人的聊天记录都行）</li><li>备份完成之后，将该 <code>Backup</code> 目录复制到移动硬盘下的某个目录，比如 <code>/Volumes/硬盘名/backup/wechat</code></li><li>复制完成之后就可以把微信默认备份路径下的 <code>Backup</code> 目录删除了，当然你不放心的话，也可以删除前先备份一下。</li><li>然后创建软连接，打开终端，执行如下命令。（注意。此处的 <code>硬盘名</code> 要改成你自己的外置硬盘的盘符名称）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /Volumes/硬盘名/backup/wechat/Backup ~/Library/Containers/com.tencent.xinWeChat/Data/Library/Application\ Support/com.tencent.xinWeChat/2.0b4.0.9/Backup</span><br></pre></td></tr></table></figure><ul><li><p>此时就能看到软连接已经创建好了，微信目录下的Backup已经指向到了移动硬盘下的Backup目录</p><p><img src="https://pic.oldzhg.com/uPic/image-1663225770604.webp" alt="image-1663225770604"></p></li><li><p>第一步的时候我们已经备份了一次，此时进入微信的备份设置那里进入<code>管理备份文件</code>栏目之后，按道理是能看到一个备份的，但是实际上却毛都没有，这又是闹哪样呢</p></li><li><p>因为mac下的应用是以沙盒模式运行，无法直接读取不在该应用程序目录以外的目录，所以虽然创建软连接把备份目录指向外置硬盘了，但实际上还是读取不到的。要解决这个问题需要先退出微信，然后重新签名微信，再执行如下代码即可给微信重新签名。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo codesign --sign - --force --deep /Applications/WeChat.app</span><br></pre></td></tr></table></figure><ul><li><p>重签之后再打开微信，再次进入<code>管理备份文件</code> 栏目,会弹出一个是否允许访问外挂硬盘的提示，点击同意之后就能看到我们之前的备份了</p><div align=center><img src="https://pic.oldzhg.com/uPic/image-1663226325395.webp" alt="image-1663226325395" style="zoom:50%;" /></div></li></ul><h2 id="话外"><a href="#话外" class="headerlink" title="话外"></a>话外</h2><ul><li>软链接的方式更方便，只要硬盘插着的，你执行备份、恢复的操作都会直接走移动硬盘，相当于直接正常操作就会把文件备份到移动硬盘里面。既不占用电脑存储空间，又不需要额外操作。</li><li>很早之前我就用过创建软连接的方式来备份微信聊天记录到外置存储，那时候直接创建软连接就完事了，创建完就能正常读取恢复， 但是后面不知道什么时候开始就出问题了，软连接还在，但是备份恢复都不好使了，完全读取不到了。尝试过很多办法都没解决，最终搜到了 <a href="https://blog.zcw159357.com/article/1/2021-07-20-0033.html" target="_blank" rel="noopener">这篇博客</a> 才终于发现了解决方案，非常感谢这个博主。</li><li>经过博主测试，备份、恢复、插拔硬盘之后再操作、重启微信之后再操作均正常，但是还没试过更新微信之后是什么效果，不过目测更新微信版本之后应该会失效，不过解决方法也很简单，重新执行签名命令签名一次就行。</li></ul><h3 id="转自：https-luoxx-top-archives-mac-wechat-backup-path"><a href="#转自：https-luoxx-top-archives-mac-wechat-backup-path" class="headerlink" title="转自：https://luoxx.top/archives/mac-wechat-backup-path"></a>转自：<a href="https://luoxx.top/archives/mac-wechat-backup-path" target="_blank" rel="noopener">https://luoxx.top/archives/mac-wechat-backup-path</a></h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;mac版本微信中并没有指定备份路径的功能，备份的聊天记录文件也在一个很难找的位置。对于使用256g硬盘的mac的用户，微信聊天记录动辄十几G、几十G的大小，会造成非常严重的硬盘容量恐慌。所以把微信备份文件迁移到外置硬盘是一件非常有意义的工
      
    
    </summary>
    
    
      <category term="工具技巧" scheme="https://www.oldzhg.com/categories/%E5%B7%A5%E5%85%B7%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="Mac" scheme="https://www.oldzhg.com/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>搭建Java Web开发环境</title>
    <link href="https://www.oldzhg.com/2020/08/11/JavaWeb-Environment/"/>
    <id>https://www.oldzhg.com/2020/08/11/JavaWeb-Environment/</id>
    <published>2020-08-11T05:47:05.000Z</published>
    <updated>2022-10-08T11:36:28.720Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h2><p>这里安装JDK1.8</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install java<span class="number">-1.8</span><span class="number">.0</span>-openjdk*</span><br></pre></td></tr></table></figure><h2 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h2><ol><li><p>下载并安装MySQL</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget http://dev.mysql.com/get/mysql57-community-<span class="keyword">release</span>-el7<span class="number">-10.</span>noarch.rpm</span><br><span class="line">yum -y <span class="keyword">install</span> mysql57-community-<span class="keyword">release</span>-el7<span class="number">-10.</span>noarch.rpm</span><br><span class="line">yum -y <span class="keyword">install</span> mysql-community-<span class="keyword">server</span></span><br></pre></td></tr></table></figure></li><li><p>启动MySQL</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="literal">start</span> mysqld.service</span><br></pre></td></tr></table></figure></li></ol><h2 id="安装Tomcat"><a href="#安装Tomcat" class="headerlink" title="安装Tomcat"></a>安装Tomcat</h2><h3 id="Tomcat是什么？"><a href="#Tomcat是什么？" class="headerlink" title="Tomcat是什么？"></a>Tomcat是什么？</h3><p>Tomcat是一个应用服务器。他的作用就是让你写好的Java网站在服务器上运行。</p><h3 id="Tomcat安装步骤"><a href="#Tomcat安装步骤" class="headerlink" title="Tomcat安装步骤"></a>Tomcat安装步骤</h3><ol><li><p>下载并解压Tomcat压缩包</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https:<span class="regexp">//mi</span>rror.bit.edu.cn<span class="regexp">/apache/</span>tomcat<span class="regexp">/tomcat-8/</span>v8.<span class="number">5.57</span><span class="regexp">/bin/</span>apache-tomcat-<span class="number">8.5</span>.<span class="number">57</span>.tar.gz</span><br><span class="line">tar -zxvf apache-tomcat-<span class="number">8.5</span>.<span class="number">57</span>.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>修改Tomcat名字</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv apache-tomcat<span class="number">-8.5</span><span class="number">.57</span> /usr/local/Tomcat8<span class="number">.5</span></span><br></pre></td></tr></table></figure></li><li><p>为Tomcat授权</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x <span class="regexp">/usr/</span>local<span class="regexp">/Tomcat8.5/</span>bin<span class="regexp">/*.sh</span></span><br></pre></td></tr></table></figure></li><li><p>修改Tomcat默认端口号（默认为8080）</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i <span class="symbol">'s</span>/Connector <span class="keyword">port</span>=<span class="string">"8080"</span>/Connector <span class="keyword">port</span>=<span class="string">"80"</span>/' /usr/local/Tomcat8.<span class="number">5</span>/conf/server.xml</span><br></pre></td></tr></table></figure></li><li><p>启动Tomcat</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/usr/</span>local<span class="regexp">/Tomcat8.5/</span>bin<span class="regexp">/./</span>startup.sh</span><br></pre></td></tr></table></figure></li><li><p>访问Tomcat</p><p>访问服务器公网地址</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h2 id=&quot;安装JDK&quot;&gt;&lt;a href=&quot;#安装JDK&quot; class=&quot;headerlink&quot; title=&quot;安装JDK&quot;&gt;&lt;/a&gt;安装JDK&lt;/h2&gt;&lt;p&gt;这里安装JDK1.8&lt;/p&gt;
&lt;figure class=&quot;highlight angelscript&quot;&gt;
      
    
    </summary>
    
    
      <category term="ECS七天训练营" scheme="https://www.oldzhg.com/categories/ECS%E4%B8%83%E5%A4%A9%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
    
  </entry>
  
  <entry>
    <title>打造离线下载服务器</title>
    <link href="https://www.oldzhg.com/2020/08/10/CCAA-DownloadServer/"/>
    <id>https://www.oldzhg.com/2020/08/10/CCAA-DownloadServer/</id>
    <published>2020-08-10T11:49:55.000Z</published>
    <updated>2022-10-08T11:36:28.719Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装CCAA-CentOS-Caddy-AriaNg-Aria"><a href="#安装CCAA-CentOS-Caddy-AriaNg-Aria" class="headerlink" title="安装CCAA(CentOS + Caddy + AriaNg + Aria)"></a>安装CCAA(CentOS + Caddy + AriaNg + Aria)</h2><p>一键脚本，一路回车就完事</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash &lt;(curl -Lsk https://raw.githubusercontent.com/helloxz/ccaa/master/ccaa.sh) cdn</span><br></pre></td></tr></table></figure><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p><code>ccaa</code>:进⼊CCAA操作界⾯ </p><p><code>ccaa status</code>:查看CCAA运⾏状态 </p><p><code>ccaa stop</code>:停⽌CCAA </p><p><code>ccaa start</code>:启动CCAA</p><p><code>ccaa restart</code>:重启CCAA</p><p><code>ccaa -v</code>:查看CCAA版本（2.0开始⽀持）</p><h2 id="下载页面"><a href="#下载页面" class="headerlink" title="下载页面"></a>下载页面</h2><p><img src="https://pic.oldzhg.com/uPic/D2XLDg.png" alt="aria2NG"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装CCAA-CentOS-Caddy-AriaNg-Aria&quot;&gt;&lt;a href=&quot;#安装CCAA-CentOS-Caddy-AriaNg-Aria&quot; class=&quot;headerlink&quot; title=&quot;安装CCAA(CentOS + Caddy + AriaNg
      
    
    </summary>
    
    
      <category term="ECS七天训练营" scheme="https://www.oldzhg.com/categories/ECS%E4%B8%83%E5%A4%A9%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
    
  </entry>
  
  <entry>
    <title>基于ECS构建微信公众号管理系统</title>
    <link href="https://www.oldzhg.com/2020/08/08/WeEngine/"/>
    <id>https://www.oldzhg.com/2020/08/08/WeEngine/</id>
    <published>2020-08-08T13:01:22.000Z</published>
    <updated>2022-10-08T11:36:28.721Z</updated>
    
    <content type="html"><![CDATA[<h3 id="下载解压"><a href="#下载解压" class="headerlink" title="下载解压"></a>下载解压</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://cdn.w7.cc/download/WeEngine-Laster-Online.zip</span><br><span class="line">unzip -d wechat WeEngine-Laster-Online.zip</span><br></pre></td></tr></table></figure><p>修改nginx默认目录到wechat,重启nginx</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p</span><br><span class="line">create database wechat;</span><br><span class="line">show databases;</span><br></pre></td></tr></table></figure><img src="https://oss.oldzhg.com/uPic/image-20200808202241760.png" alt="image-20200808202241760" style="zoom:50%;" /><h3 id="开始部署"><a href="#开始部署" class="headerlink" title="开始部署"></a>开始部署</h3><p>打开网站，<code>http://ip/install.php</code></p><img src="https://pic.oldzhg.com/uPic/Xnip2020-08-08_20-18-00.jpg" alt="Xnip2020-08-08_20-18-00" style="zoom:50%;" /><p>发现目录权限不足，授予刚刚创建的wechat目录权限即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown -R www &#x2F;data&#x2F;wwwroot&#x2F;wechat</span><br></pre></td></tr></table></figure><p>继续安装</p><img src="https://pic.oldzhg.com/uPic/image-20200808202633209.png" alt="image-20200808202633209" style="zoom:50%;" /><p>到这里就基本完成系统的部署</p><h3 id="添加公众号"><a href="#添加公众号" class="headerlink" title="添加公众号"></a>添加公众号</h3><p>剩下就是微信公众号的添加，不再赘述</p><p>完成大概这个样子</p><img src="https://pic.oldzhg.com/uPic/image-20200808205941459.png" alt="image-20200808205941459" style="zoom:50%;" />]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;下载解压&quot;&gt;&lt;a href=&quot;#下载解压&quot; class=&quot;headerlink&quot; title=&quot;下载解压&quot;&gt;&lt;/a&gt;下载解压&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre
      
    
    </summary>
    
    
      <category term="ECS七天训练营" scheme="https://www.oldzhg.com/categories/ECS%E4%B8%83%E5%A4%A9%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
    
  </entry>
  
  <entry>
    <title>MediaWiki</title>
    <link href="https://www.oldzhg.com/2020/08/07/MediaWiki/"/>
    <id>https://www.oldzhg.com/2020/08/07/MediaWiki/</id>
    <published>2020-08-07T11:59:20.000Z</published>
    <updated>2022-10-08T11:36:28.720Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装运行环境"><a href="#安装运行环境" class="headerlink" title="安装运行环境"></a>安装运行环境</h2><p>这里建议<a href="https://oneinstack.com" target="_blank" rel="noopener">onestack</a>一键脚本搭建LNMP环境</p><h2 id="下载MediaWiki"><a href="#下载MediaWiki" class="headerlink" title="下载MediaWiki"></a>下载MediaWiki</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://releases.wikimedia.org/mediawiki/1.29/mediawiki-1.29.1.tar.gz</span><br><span class="line">tar -zxvf mediawiki-1.29.1.tar.gz</span><br></pre></td></tr></table></figure><h2 id="配置nginx"><a href="#配置nginx" class="headerlink" title="配置nginx"></a>配置nginx</h2><p>修改一下目录的权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown -R www /data/wwwroot/mediawiki</span><br></pre></td></tr></table></figure><p>再改一下nginx.conf的默认目录到mediawiki</p><h2 id="安装MediaWiki"><a href="#安装MediaWiki" class="headerlink" title="安装MediaWiki"></a>安装MediaWiki</h2><p>输入公网ip就可以啦，按照指示很快就能弄好</p><p><img src="https://pic.oldzhg.com/uPic/BPWBCn.png" alt=""></p><p>安装成功的样子</p><p><img src="https://oss.oldzhg.com/uPic/Xnip2020-08-07_20-09-05.jpg" alt="Xnip2020-08-07_20-09-05"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装运行环境&quot;&gt;&lt;a href=&quot;#安装运行环境&quot; class=&quot;headerlink&quot; title=&quot;安装运行环境&quot;&gt;&lt;/a&gt;安装运行环境&lt;/h2&gt;&lt;p&gt;这里建议&lt;a href=&quot;https://oneinstack.com&quot; target=&quot;_blank&quot; r
      
    
    </summary>
    
    
      <category term="ECS七天训练营" scheme="https://www.oldzhg.com/categories/ECS%E4%B8%83%E5%A4%A9%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
    
  </entry>
  
  <entry>
    <title>VuePress</title>
    <link href="https://www.oldzhg.com/2020/08/06/VuePress/"/>
    <id>https://www.oldzhg.com/2020/08/06/VuePress/</id>
    <published>2020-08-06T12:24:25.000Z</published>
    <updated>2022-10-08T11:36:28.721Z</updated>
    
    <content type="html"><![CDATA[<h2 id="VuePress"><a href="#VuePress" class="headerlink" title="VuePress"></a>VuePress</h2><p>轻量级文档服务器，可以用做博客和技术文档，可以部署在Github</p><h3 id="VuePress优点"><a href="#VuePress优点" class="headerlink" title="VuePress优点"></a>VuePress优点</h3><ol><li>界面简洁优雅</li><li>支持Markdown语法</li><li>渲染静态HTML，性能优异</li></ol><h3 id="远程安装VuePress"><a href="#远程安装VuePress" class="headerlink" title="远程安装VuePress"></a>远程安装VuePress</h3><ol><li>设置安全组</li></ol><ul><li>登录到阿里云服务器</li><li>进入控制台，选择ecs</li><li>选择网络与安全</li><li>选择安全组，选择实例，进去</li><li>在入方向选择手动创建</li><li>协议选择自定义TCP，端口范围为22/22和8080/8080，授权对象0.0.0.0/0，保存</li><li>退出到实例与镜像里，选择实例，查看公网ip</li><li>可以使用XSHELL，远程连接公网ip，输入账号密码测试连接</li></ul><ol start="2"><li>安装node.js（官方那个太麻烦了，顶不住，顶不住）</li></ol><ul><li>在官方网站查询你需要的node的版本资源<code>https://github.com/nodesource/distributions</code></li><li>给系统添加你需要安装的node资源<code>curl -sL https://rpm.nodesource.com/setup_10.x | bash -</code></li><li>安装ndoe.js<code>yum install -y nodejs</code></li><li>输入<code>node -v</code>和<code>npm -v</code>查看是否已经安装上了，以及版本是否正确</li></ul><ol start="3"><li>安装VuePress</li></ol><ul><li>配置node.js的镜像（国内访问国外太慢了，依旧顶不住）<code>npm config set registry &quot; https://registry.npm.taobao.org &quot;</code></li><li>输入<code>npm config get registry</code>查看是否配置成功</li><li>安装yarn包管理器<code>npm install -g yarn</code>（官方有俩种安装VuePress的方法，yarn的方法比npm直接安装的速度快）</li><li>通过yarn安装VuePress<code>npm install yarn -g</code></li><li>这个时候出现错误，可能是node版本太低了，升级一下node版本<code>n stable</code>（升级好慢啊）</li><li>重新安装</li><li>输入<code>VuePress -v</code>查看是否安装成功</li></ul><p><strong>VuePress目录结构</strong></p><p><img src="https://pic.oldzhg.com/uPic/ibSXcC.png" alt=""></p><h3 id="配置VuePress"><a href="#配置VuePress" class="headerlink" title="配置VuePress"></a>配置VuePress</h3><ol><li>创建一个文件夹，名字为VuePress<code>mkdir vuepress</code>，进入到文件夹内部<code>cd vuepress</code></li><li>然后创建package.json文件夹<code>npm init -y</code>，这个时候会创建出package.json文件，可以ls查看一下</li><li>修改package.json文件<code>vi package.json</code></li><li>修改成这样</li></ol><p>保存，退出</p><ol start="5"><li>接着创建文件夹 docs <code>mkdir docs</code></li><li>进入到内部<code>cd docs</code></li><li>创建文件<code>echo &#39;# Hello VuePress - first blog!&#39; &gt;README.md</code>文件夹<code>mkdir .vuepress</code>进入到文件夹里</li><li>创建文件夹和配置文件<code>mkdir public</code>和<code>echo &gt; config.js</code></li><li>回到最初的目录<code>cd ../../</code></li><li>然后启动vuepress<code>vuepress dev docs</code></li><li>打开浏览器输入服务器公网ip及端口号8080，即可看见刚刚写入的hello  VuePress</li></ol><h3 id="个性化定制"><a href="#个性化定制" class="headerlink" title="个性化定制"></a>个性化定制</h3><p>修改README.md⽂件，将原来的内容删除后，将以下内容拷贝进去</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">home:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">heroText:</span> <span class="string">Vue技术博客初试</span></span><br><span class="line"><span class="attr">tagline:</span> <span class="string">项⽬目结构，关注讨论，每⽇日分享</span></span><br><span class="line"><span class="attr">actionText:</span> <span class="string">每⽇日更更新</span> <span class="string">→</span></span><br><span class="line"><span class="attr">actionLink:</span> <span class="string">/testlink/</span></span><br><span class="line"><span class="attr">features:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">title:</span> <span class="string">项⽬目结构</span></span><br><span class="line"><span class="attr">details:</span> <span class="string">以</span> <span class="string">Markdown</span> <span class="string">为中⼼心的项⽬目结构，以最少的配置帮助你专注于写作。</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">title:</span> <span class="string">关注讨论</span></span><br><span class="line"><span class="attr">details:</span> <span class="string">享受</span> <span class="string">Vue</span> <span class="string">+</span> <span class="string">webpack</span> <span class="string">的开发体验，在</span> <span class="string">Markdown</span> <span class="string">中使⽤用</span> <span class="string">Vue</span> <span class="string">组件，同</span></span><br><span class="line"><span class="string">时可以使⽤用</span> <span class="string">Vue</span> <span class="string">来开发⾃自定义主题。</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">title:</span> <span class="string">每⽇日分享</span></span><br><span class="line"><span class="attr">details:</span> <span class="string">VuePress</span> <span class="string">为每个⻚页⾯面预渲染⽣生成静态的</span> <span class="string">HTML，同时在⻚页⾯面被加载的</span></span><br><span class="line"><span class="string">时候，将作为</span> <span class="string">SPA</span> <span class="string">运⾏行行。</span></span><br><span class="line"><span class="attr">footer:</span> <span class="string">LearnVueonECS</span> <span class="string">Licensed</span> <span class="string">|</span> <span class="string">Copyright</span> <span class="string">©</span> <span class="number">2020</span><span class="string">-present</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p>演示效果如下</p><p><img src="https://oss.oldzhg.com/uPic/image-20200806201815666.png" alt="image-20200806201815666"></p><p>你也可以自己继续换主题，定制插件让样式更多样，在官网上就有介绍<a href="https://www.vuepress.cn/" target="_blank" rel="noopener">VuePress官网</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;VuePress&quot;&gt;&lt;a href=&quot;#VuePress&quot; class=&quot;headerlink&quot; title=&quot;VuePress&quot;&gt;&lt;/a&gt;VuePress&lt;/h2&gt;&lt;p&gt;轻量级文档服务器，可以用做博客和技术文档，可以部署在Github&lt;/p&gt;
&lt;h3 id=&quot;V
      
    
    </summary>
    
    
      <category term="ECS七天训练营" scheme="https://www.oldzhg.com/categories/ECS%E4%B8%83%E5%A4%A9%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
    
  </entry>
  
  <entry>
    <title>Markdown基本语法</title>
    <link href="https://www.oldzhg.com/2020/03/30/Markdown-basic-syntax/"/>
    <id>https://www.oldzhg.com/2020/03/30/Markdown-basic-syntax/</id>
    <published>2020-03-30T06:27:55.000Z</published>
    <updated>2022-10-08T11:36:28.720Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Markdown简介"><a href="#Markdown简介" class="headerlink" title="Markdown简介"></a>Markdown简介</h1><p>Markdown是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。</p><p>相比WYSIWYG编辑器</p><p><strong>优点：</strong><br>1、因为是纯文本，所以只要支持Markdown的地方都能获得一样的编辑效果，可以让作者摆脱排版的困扰，专心写作。<br>2、操作简单。比如:WYSIWYG编辑时标记个标题，先选中内容，再点击导航栏的标题按钮，选择几级标题。要三个步骤。而Markdown只需要在标题内容前加#即可</p><p><strong>缺点：</strong><br>1、需要记一些语法（当然，是很简单。五分钟学会）。<br>2、有些平台不支持Markdown编辑模式。</p><p>还好，简书是支持Markdown编辑模式的。</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">开启方式：设置-&gt;默认编辑器-&gt;Markdown编辑器</span><br></pre></td></tr></table></figure><h1 id="Markdown基本使用"><a href="#Markdown基本使用" class="headerlink" title="Markdown基本使用"></a>Markdown基本使用</h1><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>在想要设置为标题的文字前面加#来表示<br>一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。</p><p>注：标准语法一般在#后跟个空格再写文字，貌似简书不加空格也行。</p><p>示例：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 这是一级标题</span><br><span class="line">## 这是二级标题</span><br><span class="line">### 这是三级标题</span><br><span class="line">#### 这是四级标题</span><br><span class="line">##### 这是五级标题</span><br><span class="line">###### 这是六级标题</span><br></pre></td></tr></table></figure><p>效果如下：</p><h2 id="这是二级标题"><a href="#这是二级标题" class="headerlink" title="这是二级标题"></a>这是二级标题</h2><h3 id="这是三级标题"><a href="#这是三级标题" class="headerlink" title="这是三级标题"></a>这是三级标题</h3><h4 id="这是四级标题"><a href="#这是四级标题" class="headerlink" title="这是四级标题"></a>这是四级标题</h4><h5 id="这是五级标题"><a href="#这是五级标题" class="headerlink" title="这是五级标题"></a>这是五级标题</h5><h6 id="这是六级标题"><a href="#这是六级标题" class="headerlink" title="这是六级标题"></a>这是六级标题</h6><hr><h2 id="段落格式"><a href="#段落格式" class="headerlink" title="段落格式"></a>段落格式</h2><ul><li><h5 id="加粗"><a href="#加粗" class="headerlink" title="加粗"></a>加粗</h5></li></ul><p>要加粗的文字左右分别用两个*号包起来</p><ul><li><h5 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h5></li></ul><p>要倾斜的文字左右分别用一个*号包起来</p><ul><li><h5 id="斜体加粗"><a href="#斜体加粗" class="headerlink" title="斜体加粗"></a>斜体加粗</h5></li></ul><p>要倾斜和加粗的文字左右分别用三个*号包起来</p><ul><li><h5 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h5></li></ul><p>要加删除线的文字左右分别用两个~~号包起来</p><p>示例：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*<span class="strong">*这是加粗的文字*</span><span class="strong">*</span></span><br><span class="line"><span class="strong">*</span>这是倾斜的文字<span class="strong">*`</span></span><br><span class="line"><span class="strong">*</span>*<span class="strong">*这是斜体加粗的文字*</span>*<span class="strong">*</span></span><br><span class="line"><span class="strong">~~这是加删除线的文字~~</span></span><br></pre></td></tr></table></figure><p>效果如下：</p><p><strong>这是加粗的文字</strong><br><em>这是倾斜的文字</em><br><strong><em>这是斜体加粗的文字</em></strong><br><del>这是加删除线的文字</del></p><hr><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;<br>n个…<br>貌似可以一直加下去，但没神马卵用</p><p>示例：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;这是引用的内容</span><br><span class="line"><span class="meta">&gt;&gt;</span>这是引用的内容</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容</span><br></pre></td></tr></table></figure><p>效果如下：</p><blockquote><p>这是引用的内容</p><blockquote><p>这是引用的内容</p><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>这是引用的内容</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><p>三个或者三个以上的 - 或者 * 都可以。</p><p>示例：</p><p>效果如下：<br>可以看到，显示效果是一样的。</p><hr><hr><hr><hr><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>语法：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">图片alt</span>](<span class="link">图片地址 ''图片title''</span>)</span><br><span class="line"></span><br><span class="line">图片alt就是显示在图片下面的文字，相当于对图片内容的解释。</span><br><span class="line">图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">![blockchain](https:<span class="comment">//ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/</span></span><br><span class="line">u=<span class="number">702257389</span>,<span class="number">1274025419</span>&amp;fm=<span class="number">27</span>&amp;gp=<span class="number">0.</span>jpg <span class="string">"区块链"</span>)</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="//pic.oldzhg.com/uPic/1j43ZZ.jpg" alt="blockchain"></p><p>上传本地图片直接点击导航栏的图片标志，选择图片即可**</p><p>markdown格式追求的是简单、多平台统一。那么图片的存储就是一个问题，需要用图床，提供统一的外链，这样就不用在不同的平台去处理图片的问题了。才能做到书写一次，各处使用。<br>关于图床的选择我写了一篇文章，对网上存在的各种方法做了总结，需要的朋友可以看看。<a href="https://www.jianshu.com/p/ea1eb11db63f" target="_blank" rel="noopener">markdown图床</a></p><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p>语法：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">超链接名</span>](<span class="link">超链接地址 "超链接title"</span>)</span><br><span class="line">title可加可不加</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">简书</span>](<span class="link">http://jianshu.com</span>)</span><br><span class="line">[<span class="string">百度</span>](<span class="link">http://baidu.com</span>)</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><a href="https://www.jianshu.com/u/1f5ac0cf6a8b" target="_blank" rel="noopener">简书</a><br><a href="https://links.jianshu.com/go?to=http%3A%2F%2Fbaidu.com" target="_blank" rel="noopener">百度</a></p><p>注：Markdown本身语法不支持链接在新页面中打开，貌似简书做了处理，是可以的。别的平台可能就不行了，如果想要在新页面中打开的话可以用html语言的a标签代替。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;a <span class="attribute">href</span>=<span class="string">"超链接地址"</span> <span class="attribute">target</span>=<span class="string">"_blank"</span>&gt;超链接名&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">示例</span><br><span class="line">&lt;a <span class="attribute">href</span>=<span class="string">"https://www.jianshu.com/u/1f5ac0cf6a8b"</span> <span class="attribute">target</span>=<span class="string">"_blank"</span>&gt;简书&lt;/a&gt;</span><br></pre></td></tr></table></figure><hr><h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><p>语法：<br>无序列表用 - + * 任何一种都可以</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>列表内容</span><br><span class="line"><span class="bullet">+ </span>列表内容</span><br><span class="line"><span class="bullet">* </span>列表内容</span><br><span class="line"></span><br><span class="line">注意：- + * 跟内容之间都要有一个空格</span><br></pre></td></tr></table></figure><p>效果如下：</p><ul><li>列表内容</li><li>列表内容</li><li>列表内容</li></ul><h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><p>语法：<br>数字加点</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 列表内容</span><br><span class="line"><span class="number">2.</span> 列表内容</span><br><span class="line"><span class="number">3.</span> 列表内容</span><br><span class="line"></span><br><span class="line">注意：序号跟内容之间要有空格</span><br></pre></td></tr></table></figure><p>效果如下：</p><ol><li>列表内容</li><li>列表内容</li><li>列表内容</li></ol><h2 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h2><p><strong>上一级和下一级之间敲三个空格即可</strong></p><ul><li><p>一级无序列表内容</p><ul><li>二级无序列表内容</li><li>二级无序列表内容</li><li>二级无序列表内容</li></ul></li><li><p>一级无序列表内容</p><ol><li>二级有序列表内容</li><li>二级有序列表内容</li><li>二级有序列表内容</li></ol></li></ul><ol><li><p>一级有序列表内容</p><ul><li>二级无序列表内容</li><li>二级无序列表内容</li><li>二级无序列表内容</li></ul></li><li><p>一级有序列表内容</p><ol><li>二级有序列表内容</li><li>二级有序列表内容</li><li>二级有序列表内容</li></ol></li></ol><hr><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>语法：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">表头|<span class="string">表头</span>|<span class="string">表头</span></span><br><span class="line"><span class="string">---</span>|<span class="string">:--:</span>|<span class="string">---:</span></span><br><span class="line"><span class="string">内容</span>|<span class="string">内容</span>|<span class="string">内容</span></span><br><span class="line"><span class="string">内容</span>|<span class="string">内容</span>|<span class="string">内容</span></span><br><span class="line"></span><br><span class="line"><span class="string">第二行分割表头和内容。</span></span><br><span class="line"><span class="string">- 有一个就行，为了对齐，多加了几个</span></span><br><span class="line"><span class="string">文字默认居左</span></span><br><span class="line"><span class="string">-两边加：表示文字居中</span></span><br><span class="line"><span class="string">-右边加：表示文字居右</span></span><br><span class="line"><span class="string">注：原生的语法两边都要用 </span>|<span class="string"> 包起来。此处省略</span></span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">姓名|<span class="string">技能</span>|<span class="string">排行</span></span><br><span class="line"><span class="string">--</span>|<span class="string">:--:</span>|<span class="string">--:</span></span><br><span class="line"><span class="string">刘备</span>|<span class="string">哭</span>|<span class="string">大哥</span></span><br><span class="line"><span class="string">关羽</span>|<span class="string">打</span>|<span class="string">二哥</span></span><br><span class="line"><span class="string">张飞</span>|<span class="string">骂</span>|<span class="string">三弟</span></span><br></pre></td></tr></table></figure><p>效果如下：</p><table><thead><tr><th>姓名</th><th>技能</th><th>排行</th></tr></thead><tbody><tr><td>刘备</td><td>哭</td><td>大哥</td></tr><tr><td>关羽</td><td>打</td><td>二哥</td></tr><tr><td>张飞</td><td>骂</td><td>三弟</td></tr></tbody></table><p>语法：<br>单行代码：代码之间分别用一个反引号包起来</p><p>代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(```)</span><br><span class="line">  代码...</span><br><span class="line">  代码...</span><br><span class="line">  代码...</span><br><span class="line">(```)</span><br></pre></td></tr></table></figure><blockquote><p>注：为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可。</p></blockquote><p>示例：</p><p>单行代码</p><p>代码块</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(```)</span><br><span class="line">    function <span class="function"><span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">         echo <span class="string">"这是一句非常牛逼的代码"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">fun</span><span class="params">()</span></span>;</span><br><span class="line">(```)</span><br></pre></td></tr></table></figure><p>效果如下：</p><p>单行代码</p><p><code>create database hero;</code></p><p>代码块</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function <span class="function"><span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">  echo <span class="string">"这是一句非常牛逼的代码"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">fun</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: 开始</span><br><span class="line">op=&gt;operation: My Operation</span><br><span class="line">cond=&gt;condition: Yes <span class="keyword">or</span> No?</span><br><span class="line">e=&gt;end</span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond<span class="function"><span class="params">(<span class="literal">yes</span>)</span>-&gt;</span>e</span><br><span class="line">cond<span class="function"><span class="params">(<span class="literal">no</span>)</span>-&gt;</span>op</span><br><span class="line">&amp;``<span class="javascript"><span class="string">`</span></span></span><br></pre></td></tr></table></figure><p>效果如下：    </p><p><img src="//pic.oldzhg.com/uPic/ugJWHL.png" alt="流程图.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Markdown简介&quot;&gt;&lt;a href=&quot;#Markdown简介&quot; class=&quot;headerlink&quot; title=&quot;Markdown简介&quot;&gt;&lt;/a&gt;Markdown简介&lt;/h1&gt;&lt;p&gt;Markdown是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通
      
    
    </summary>
    
    
      <category term="工具技巧" scheme="https://www.oldzhg.com/categories/%E5%B7%A5%E5%85%B7%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="Tech" scheme="https://www.oldzhg.com/tags/Tech/"/>
    
  </entry>
  
  <entry>
    <title>SSH隧道技术简介端口转发&amp;SOCKS代理</title>
    <link href="https://www.oldzhg.com/2020/03/28/Introduction-of-SSH-tunneling-technology/"/>
    <id>https://www.oldzhg.com/2020/03/28/Introduction-of-SSH-tunneling-technology/</id>
    <published>2020-03-28T10:26:04.000Z</published>
    <updated>2022-10-08T11:36:28.720Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、本文的受众"><a href="#1、本文的受众" class="headerlink" title="1、本文的受众"></a>1、本文的受众</h1><p>如果你遇到了以下问题，那么你应该阅读这篇文章</p><ol><li><p>我听说过这种技术，我对它很感兴趣</p></li><li><p>我想在家里访问我在公司的机器（写程序，查数据，下电影）。</p></li><li><p>公司为了防止我们用XX软件封锁了它的端口或者服务器地址。</p></li><li><p>公司不让我们上XX网站，限制了网址甚至IP。</p></li><li><p>公司不让我们看关于XX的信息，甚至花血本买了XX设备，能够对内容进行过滤。一看XX内容，链接就中断了。</p></li><li><p>我爸是搞电脑的，他在家里的路由器上动了手脚，我不能看XXX了。</p></li></ol><p>带着这些问题，我们先从什么是ssh隧道开始。</p><h1 id="2、什么是SSH隧道"><a href="#2、什么是SSH隧道" class="headerlink" title="2、什么是SSH隧道"></a>2、什么是SSH隧道</h1><p>首先看下面这张图，我们所面临的大部分情况都和它类似。我们的电脑在右上角，通过公司带有防火墙功能的路由器接入互联网（当然可能还有交换机什么的在中间连接着你和路由器，但是在我们的问题中交换机并不起到什么关键性的作用）。右下脚的部分是一个网站的服务器，它是我们公司防火墙策略的一部分，也就是说公司不希望我们访问这个服务器。在右上角还有一台机器，它也是属于我们的。但是这台机器并不在我们公司里面，换句话说他不受到公司防火墙的限制。最后也是最重要的一点是，我们能够在公司通过互联网直接访问这台机器。或者说这台位于公司防火墙外面的机器需要拥有一个独立的互联网IP，同时公司的防火墙规则不会屏蔽这台机器，并且这台机器运行着一个OpenSSH服务器。</p><p><img src="//pic.oldzhg.com/uPic/BGUrhZ.jpg" alt=""></p><p>现在，我们清楚地知道了自己所处的网络环境。并且不难理解我们在公司无法访问那个服务器的原因是：线路A-B-C上A-B之间的防火墙屏蔽了对那个服务器的访问。与此同时，我们也很快注意到，线路A-B-D之间、D-C之间是不受阻碍的。相信你已经想到了，在A-B之间的防火墙不会屏蔽对机器d的访问。因此我们可以通过机器d建立一个通道A-B-D-C，从而访问到机器c上的数据。</p><p>这条通道可以用很多技术来建立，这里我们仅仅介绍如何使用SSH服务器来建立这样一个通道－他被称为SSH隧道。</p><h1 id="3、如何建立本地SSH隧道"><a href="#3、如何建立本地SSH隧道" class="headerlink" title="3、如何建立本地SSH隧道"></a>3、如何建立本地SSH隧道</h1><p>在我们计划建立一个本地SSH隧道之前，我们必须清楚下面这些数据：</p><ol><li><p>中间服务器d的IP地址</p></li><li><p>要访问服务器c的IP地址</p></li><li><p>要访问服务器c的端口</p></li></ol><p>现在，我们把上面这张图变得具体一些，给这些机器加上IP地址。并且根据下面这张图列出我们的计划：</p><p><img src="//pic.oldzhg.com/uPic/d9L5Fz.jpg" alt=""></p><ol><li><p>需要访问234.234.234.234的FTP服务，也就是端口21</p></li><li><p>中间服务器是123.123.123.123</p></li></ol><p>现在我们使用下面这条命令来达成我们的目的</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh -N -f -L <span class="number">2121</span>:<span class="number">234.234</span><span class="number">.234</span><span class="number">.234</span>:<span class="number">21</span> <span class="number">123.123</span><span class="number">.123</span><span class="number">.123</span></span><br><span class="line">ftp localhost:<span class="number">2121</span> # 现在访问本地<span class="number">2121</span>端口，就能连接<span class="number">234.234</span><span class="number">.234</span><span class="number">.234</span>的<span class="number">21</span>端口了</span><br></pre></td></tr></table></figure><p>这里我们用到了SSH客户端的三个参数，下面我们一一做出解释：</p><ul><li><p>-N 告诉SSH客户端，这个连接不需要执行任何命令。仅仅做端口转发</p></li><li><p>-f 告诉SSH客户端在后台运行</p></li><li><p>-L 做本地映射端口，被冒号分割的三个部分含义分别是</p><ul><li><p>需要使用的本地端口号</p></li><li><p>需要访问的目标机器IP地址（IP: 234.234.234.234）</p></li><li><p>需要访问的目标机器端口（端口: 21)</p></li></ul></li><li><p>最后一个参数是我们用来建立隧道的中间机器的IP地址(IP: 123.123.123.123)</p></li></ul><p>我们再重复一下-L参数的行为。-L X:Y:Z的含义是，将IP为Y的机器的Z端口通过中间服务器映射到本地机器的X端口。</p><p>在这条命令成功执行之后，我们已经具有绕过公司防火墙的能力，并且成功访问到了我们喜欢的一个FTP服务器了。</p><h1 id="4、如何建立远程SSH隧道"><a href="#4、如何建立远程SSH隧道" class="headerlink" title="4、如何建立远程SSH隧道"></a>4、如何建立远程SSH隧道</h1><p>通过建立本地SSH隧道，我们成功地绕过防火墙开始下载FTP上的资源了。那么当我们在家里的时候想要察看下载进度怎么办呢？大多数公司的网络是通过路由器接入互联网的，公司内部的机器不会直接与互联网连接，也就是不能通过互联网直接访问。通过线路D-B-A访问公司里的机器a便是不可能的。也许你已经注意到了，虽然D-B-A这个方向的连接不通，但是A-B-D这个方向的连接是没有问题的。那么，我们能否利用一条已经连接好的A-B-D方向的连接来完成D-B-A方向的访问呢？答案是肯定的，这就是远程SSH隧道的用途。</p><p>与本地SSH一样，我们在建立远程SSH隧道之前要清楚下面几个参数：</p><ul><li><p>需要访问内部机器的远程机器的IP地址（这里是123.123.123.123）</p></li><li><p>需要让远程机器能访问的内部机器的IP地址(这里因为是想把本机映射出去，因此IP是127.0.0.1)</p></li><li><p>需要让远程机器能访问的内部机器的端口号(端口:22)</p></li></ul><p>在清楚了上面的参数后，我们使用下面的命令来建立一个远程SSH隧道</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -N -f -R <span class="number">2222</span>:<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">22</span> <span class="number">123.123</span><span class="number">.123</span><span class="number">.123</span></span><br></pre></td></tr></table></figure><p>现在，在IP是123.123.123.123的机器上我们用下面的命令就可以登陆公司的IP是192.168.0.100的机器了。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -p <span class="number">2222</span> localhost</span><br></pre></td></tr></table></figure><p>-N，-f 这两个参数我们已经在本地SSH隧道中介绍过了。我们现在重点说说参数-R。该参数的三个部分的含义分别是:</p><ul><li><p>远程机器使用的端口（2222）</p></li><li><p>需要映射的内部机器的IP地址(127.0.0.1)</p></li><li><p>需要映射的内部机器的端口(22)</p></li></ul><p>例如：-R X:Y:Z 就是把我们内部的Y机器的Z端口映射到远程机器的X端口上。</p><h1 id="5、建立SSH隧道的几个技巧"><a href="#5、建立SSH隧道的几个技巧" class="headerlink" title="5、建立SSH隧道的几个技巧"></a>5、建立SSH隧道的几个技巧</h1><h2 id="5-1-自动重连"><a href="#5-1-自动重连" class="headerlink" title="5.1 自动重连"></a><strong>5.1 自动重连</strong></h2><p>隧道可能因为某些原因断开，例如：机器重启，长时间没有数据通信而被路由器切断等等。因此我们可以用程序控制隧道的重新连接，例如一个简单的循环或者使用 <a href="http://cr.yp.to/daemontools.html" target="_blank" rel="noopener">djb’s daemontools</a> . 不管用哪种方法，重连时都应避免因输入密码而卡死程序。关于如何安全的避免输入密码的方法，请参考我的 <a href="http://blog.jianingy.com/node/73" target="_blank" rel="noopener">如何实现安全的免密码ssh登录</a> 。这里请注意，如果通过其他程序控制隧道连接，应当避免将SSH客户端放到后台执行，也就是去掉-f参数。</p><h2 id="5-2-保持长时间连接"><a href="#5-2-保持长时间连接" class="headerlink" title="5.2 保持长时间连接"></a><strong>5.2 保持长时间连接</strong></h2><p>有些路由器会把长时间没有通信的连接断开。SSH客户端的TCPKeepAlive选项可以避免这个问题的发生，默认情况下它是被开启的。如果它被关闭了，可以在ssh的命令上加上-o TCPKeepAlive=yes来开启。</p><p>另一种方法是，去掉-N参数，加入一个定期能产生输出的命令。例如: top或者vmstat。下面给出一个这种方法的例子：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -R <span class="number">2222</span>:localhost:<span class="number">22</span> <span class="number">123.123</span><span class="number">.123</span><span class="number">.123</span> <span class="string">"vmstat 30"</span></span><br></pre></td></tr></table></figure><h2 id="5-3-检查隧道状态"><a href="#5-3-检查隧道状态" class="headerlink" title="5.3 检查隧道状态"></a><strong>5.3 检查隧道状态</strong></h2><p>有些时候隧道会因为一些原因通信不畅而卡死，例如：由于传输数据量太大，被路由器带入stalled状态。这种时候，往往SSH客户端并不退出，而是卡死在那里。一种应对方法是，使用SSH客户端的ServerAliveInterval和ServerAliveCountMax选项。ServerAliveInterval会在隧道无通信后的一段设置好的时间后发送一个请求给服务器要求服务器响应。如果服务器在ServerAliveCountMax次请求后都没能响应，那么SSH客户端就自动断开连接并退出，将控制权交给你的监控程序。这两个选项的设置方法分别是在ssh时加入-o ServerAliveInterval=n和-o ServerAliveCountMax=m。其中n, m可以自行定义。</p><h2 id="5-4-如何将端口绑定到外部地址上"><a href="#5-4-如何将端口绑定到外部地址上" class="headerlink" title="5.4 如何将端口绑定到外部地址上"></a><strong>5.4 如何将端口绑定到外部地址上</strong></h2><p>使用上面的方法，映射的端口只能绑定在127.0.0.1这个接口上。也就是说，只能被本机自己访问到。如何才能让其他机器访问这个端口呢？我们可以把这个映射的端口绑定在0.0.0.0的接口上，方法是加上参数-b 0.0.0.0。同时还需要打开SSH服务器端的一个选项－GatewayPorts。默认情况下它应当是被打开的。如果被关闭的话，可以在/etc/sshd_config中修改GatewayPorts no为GatewayPorts yes来打开它。</p><h2 id="5-5-如何寻找中间服务器"><a href="#5-5-如何寻找中间服务器" class="headerlink" title="5.5 如何寻找中间服务器"></a><strong>5.5 如何寻找中间服务器</strong></h2><p>如果你家里使用ADSL上网，多半你会比较幸运。一般的ADSL（例如 <a href="http://www.chinaunicom.com/" target="_blank" rel="noopener">联通</a> 的ADSL）都是有互联网地址的。你只需要在家里的路由器上一台装有OpenSSH server机器的SSH端口映射出去即可。同时一些提供SSH访问的虚拟主机也可以用于这一用途。例如： <a href="http://www.hostmonster.com/" target="_blank" rel="noopener">Hostmonser</a> 或者 <a href="http://www.dreamhost.com/" target="_blank" rel="noopener">Dreamhost</a> .</p><h2 id="5-6-通过SSH隧道建立SOCKS服务器"><a href="#5-6-通过SSH隧道建立SOCKS服务器" class="headerlink" title="5.6 通过SSH隧道建立SOCKS服务器"></a>5.6 通过SSH隧道建立SOCKS服务器</h2><p>如果我们需要借助一台中间服务器访问很多资源，一个个映射显然不是高明的办法（事实上，高明确实没有用这个方法）。幸好，SSH客户端为我们提供了通过SSH隧道建立SOCKS服务器的功能。</p><p>通过下面的命令我们可以建立一个通过123.123.123.123的SOCKS服务器。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -N -f -D <span class="number">1080</span> <span class="number">123.123</span><span class="number">.123</span> # 将端口绑定在<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>上</span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -N -f -D <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">1080</span> <span class="number">123.123</span><span class="number">.123</span><span class="number">.123</span> # 将端口绑定在<span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>上</span><br></pre></td></tr></table></figure><p>通过SSH建立的SOCKS服务器使用的是SOCKS5协议，在为应用程序设置SOCKS代理的时候要特别注意。</p><h1 id="6、总结"><a href="#6、总结" class="headerlink" title="6、总结"></a>6、总结</h1><p>至此，我们已经对如何利用SSH隧道有一个基本的认识了。现在，文章开始时的那些问题应该迎刃而解了吧。这里要特别说一下，由于SSH隧道也使用了SSH加密协议，因此是不会被防火墙上的内容过滤器监控到的。也就是说一切在隧道中传输的数据都是被加密的。当然，离开隧道后的数据还是会保持自己原有的样子，没有加密的数据还是会被后续的路由设备监控到。</p><h1 id="7、更多阅读"><a href="#7、更多阅读" class="headerlink" title="7、更多阅读"></a>7、更多阅读</h1><p>实战 SSH 端口转发</p><p><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-sshforward/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/l-cn-sshforward/</a></p><p>‍从外网 SSH 进局域网，反向代理+正向代理解决方案‍</p><p><a href="http://segmentfault.com/a/1190000002718360" target="_blank" rel="noopener">http://segmentfault.com/a/1190000002718360</a></p><h1 id="8、参考文献"><a href="#8、参考文献" class="headerlink" title="8、参考文献"></a>8、参考文献</h1><p><a href="http://www.openssh.com/" target="_blank" rel="noopener">OpenSSH网站</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1、本文的受众&quot;&gt;&lt;a href=&quot;#1、本文的受众&quot; class=&quot;headerlink&quot; title=&quot;1、本文的受众&quot;&gt;&lt;/a&gt;1、本文的受众&lt;/h1&gt;&lt;p&gt;如果你遇到了以下问题，那么你应该阅读这篇文章&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;我听说过这种技术，我对
      
    
    </summary>
    
    
      <category term="工具技巧" scheme="https://www.oldzhg.com/categories/%E5%B7%A5%E5%85%B7%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="Tech" scheme="https://www.oldzhg.com/tags/Tech/"/>
    
  </entry>
  
  <entry>
    <title>防盗链技术</title>
    <link href="https://www.oldzhg.com/2020/03/25/Anti-hotlinking-technology/"/>
    <id>https://www.oldzhg.com/2020/03/25/Anti-hotlinking-technology/</id>
    <published>2020-03-25T02:32:36.000Z</published>
    <updated>2022-10-08T11:36:28.719Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础防盗链"><a href="#基础防盗链" class="headerlink" title="基础防盗链"></a>基础防盗链</h1><p>主要是对客户端请求所携带的一些关键信息来验证请求的合法性，比如客户端请求IP，请求URL中携带的Referer。优点是规则简单，缺点是这些信息都可以伪造，可靠性较低。</p><h2 id="IP访问控制"><a href="#IP访问控制" class="headerlink" title="IP访问控制"></a>IP访问控制</h2><p>IP地址在互联网上具有唯一性，我们可以针对异常的请求客户端的IP进行限制，以达到访问控制的目的。<br>    1. 支持对一个或多个IP的访问控制<br>    2. 针对IP段进行限制<br>    3. 对区域进行访问限制</p><h2 id="Referer防盗链"><a href="#Referer防盗链" class="headerlink" title="Referer防盗链"></a>Referer防盗链</h2><p>Referer在HTTP协议中有特殊的用途，当浏览器向服务端发送请求时会带Referer头，告知该请求是从哪个链接来的。常用于页面访问统计，图片的防盗链。</p><p>流媒体直播同样适用，当发送请求到达CDN服务器后，CDN服务器检查客户URL中是否有符合预先规定的Referer，来决定禁止或允许该请求。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>应特别指明空引用的处理方式，即该请求头中没有携带Referer头部，通常是直接在浏览器访问该URL或通过非浏览器的方式访问时，请求头不会带有Referer头部，默认采用禁止空引用的方式，当然可以自定义规则。</li><li>Refer很容易伪造，因此Referer防盗链安全性较低</li></ol><h1 id="高级防盗链"><a href="#高级防盗链" class="headerlink" title="高级防盗链"></a>高级防盗链</h1><p>流媒体直播中，常采用时间戳防盗链、swf防盗链、回源鉴权防盗链等方式。时间戳防盗链的特点是加密的URL具有时效性，无法伪造，当到达过期时间后URL不再被允许访问，适合一些对“时效性”有要求的场景。使用时间戳防盗链需要内容提供商和CDN服务商配合，内容提供商负责生成加密的URL，CDN服务商负责根据预先设定的规则对URL进行合理化验证。时间戳是由于实现原理简单、可靠性高、推荐使用。</p><p>swf防盗链为RTMP协议所特有，其特点为客户需要提前将swf文件上传到CDN节点，有客户端和CDN节点在请求过程中基于规定的算法进行加密和解密验证，CDN验证通过则响应该请求，验证失败则拒绝。</p><p>回源鉴权的特点是CDN节点每次接收到的请求，都需要先回源进行验证，验证通过才认为请求合法，继续提供服务，适用于对防盗链有很高的实时性要求的场景。另外，一些具有特殊性的防盗链，CDN默认不支持的情况下也可以考虑采用回源鉴权的形式。</p><h2 id="时间戳防盗链"><a href="#时间戳防盗链" class="headerlink" title="时间戳防盗链"></a>时间戳防盗链</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ol><li>当用户发起请求视频播放时，用户的请求会被引导至客户端源站。例如，终端用户发送的请求URL为：<a href="http://www.example.com/test.flv" target="_blank" rel="noopener">http://www.example.com/test.flv</a></li><li>源站通过一系列参数共同加密生成一串密文wsSecret。</li><li>终端用户利用源站返回的URL，重新向服务商CDN发起请求。</li><li>服务商CDN节点进行验证，请求是否过期以及加密穿是否匹配。</li></ol><p>目前服务商支持绝对时间和相对时间两种方式的时间戳防盗链控制。</p><ul><li><p>绝对时间控制方式原理如下：<br>此方式用于生成密文的参数有过期时间wsTime、请求直播流、服务商key、ip地址串。假设过期时间为：4d024e80，用户请求的直播流为：test.flv，服务商key为：abc，ip请求地址为：192.168.2.1，对以上数据进行md5加密，得到一个md5密文，假设该密文为a1b2，则源站返回给用户的URL为：<a href="http://cdn.example.com/test.flv?wsSecret=a1b2&amp;wsTime=4d024e80" target="_blank" rel="noopener">http://cdn.example.com/test.flv?wsSecret=a1b2&amp;wsTime=4d024e80</a><br>终端用户利用该URL重新向服务商节点发起请求。<br>服务商进行验证：</p><ol><li>根据过期时间wsTime和当前时间进行比较，确认请求是否过期。</li><li>根据约定的md5计算方式和密文，计算出md5加密串后和url中原始的加密串进行比较。<br>只有1和2都验证通过，请求才会被认为是合法的。不合法的请求可以采取禁止访问或者302重定向到指定的url。</li></ol></li><li><p>相对时间控制方式原理如下：<br>与绝对时间控制方式相比，相对时间控制方式使用参数keepTime和wsTime来共同决定过期时间，wsTime表示终端用户向源站请求url时，源站的机器时间，keepTime表示url 有效的时间长度，以秒为单位，以十六进制或十进制表示，同时keeptime作为参数加入加密串的计算。<br>例如： rtmp://rtmpup4.pstatp.com/live/xxxxxx/xxxx?wsSecret=xxx&amp;keeptime=7200&amp;wsTime=xxx<br>服务商节点判断该URL请求是否过期，方式如下：</p></li></ul><ul><li>若当前时间 - wsTime &lt; keepTime 时，表示URL请求未过期；</li><li>若当前时间 - wsTime &gt;= keeptime ，表示URL请求已过期；</li><li>若keepTime为空，则按照发布点配置的默认过期时间来进行判断（如5分钟）。同样，相对时间控制方式除校验有效期之外，也需要校验md5加密串是否匹配。</li></ul><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ol><li>确认时间的表示格式。默认采用的是Unix时间戳的形式，比如1371982466表示时间是2013-06-23 18:14:26，支持其他一些时间表达格式，比如：<ul><li>20130623181426</li><li>2013-06-23</li><li>51c6ca82（推荐此表示方式，将十进制的1371982466采用16进制表示，有较好的隐蔽性）</li></ul></li><li>需要确认使用绝对时间还是相对时间控制方式，使用相对时间控制的话还需要确认是否需要使用keepTime，不使用keepTime需要与客户确认默认配置的过期时长。</li><li>确认参与md5计算的相关参数，以及组合顺序。</li></ol><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><ol><li>时间戳防盗链默认支持，可以直接配置，不需要再次开发</li><li>当防盗链涉及的参数发生变更时，需要通知CDN进行配合更改，原则上密文一旦确定尽量不要发生变动，不然可能导致源和加速节点使用的密文不一致，请求全部验证不通过</li><li>使用IP进行md5计算可能带来一些问题：如果用户发送请求加密使用的IP1，而到CDN这边用的是另外一个IP2，这样就会被禁止访问。这在从4G切换到Wi-Fi时极易容易发生。</li></ol><h2 id="回源鉴权防盗链"><a href="#回源鉴权防盗链" class="headerlink" title="回源鉴权防盗链"></a>回源鉴权防盗链</h2><h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><ol><li>终端用户向CDN请求视频内容，在请求中携带需要回源鉴权的参数。例如：  <a href="http://www.test.com/live/channel.flv?key1=vaule1&key2=vaule2" target="_blank" rel="noopener">http://www.test.com/live/channel.flv?key1=vaule1&amp;key2=vaule2</a> </li><li>CDN节点可通过POST或者GET方式向用户鉴权服务器返回需要鉴权的参数，鉴权参数需要用户提前告知CDN。</li><li>鉴权服务器根据CDN传送而来的鉴权信息，进行防盗链判断，决定是否允许用户请求该直播视频，并将结果返回给CDN节点。</li><li>CDN节点根据客户鉴权服务器返回的结果，响应或者拒绝终端用户的视频请求。</li></ol><h3 id="应用场景举例："><a href="#应用场景举例：" class="headerlink" title="应用场景举例："></a>应用场景举例：</h3><ol><li>客户技术实力比较强，又不希望第三方公司知悉其防盗链原理时，可使用回源鉴权防盗链。</li><li>CDN无法满足客户特殊防盗链需求时，可使用回源鉴权防盗链。</li></ol><h3 id="使用方法："><a href="#使用方法：" class="headerlink" title="使用方法："></a>使用方法：</h3><ol><li>告知CDN，回源鉴权的参数</li><li>告知CDN，鉴权服务器地址。</li><li>告知CDN，回源鉴权的方式，目前支持get及post两种</li><li>告知CDN，鉴权结果，例如1代表成功，0代表失败</li><li>告知CDN，超时等待时间，及超时如何处理，例如，鉴权服务器3S不响应，就同意请求，或拒绝请求。</li></ol><h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a>注意事项：</h3><ol><li>每次请求都需要先进行鉴权，在请求量较大时，需要考虑鉴权服务器的压力</li><li>该鉴权形式客户需要维护专门的鉴权服务器。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基础防盗链&quot;&gt;&lt;a href=&quot;#基础防盗链&quot; class=&quot;headerlink&quot; title=&quot;基础防盗链&quot;&gt;&lt;/a&gt;基础防盗链&lt;/h1&gt;&lt;p&gt;主要是对客户端请求所携带的一些关键信息来验证请求的合法性，比如客户端请求IP，请求URL中携带的Referer。优点
      
    
    </summary>
    
    
      <category term="工具技巧" scheme="https://www.oldzhg.com/categories/%E5%B7%A5%E5%85%B7%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="Tech" scheme="https://www.oldzhg.com/tags/Tech/"/>
    
  </entry>
  
  <entry>
    <title>Django学习笔记</title>
    <link href="https://www.oldzhg.com/2020/03/23/Django-study-notes/"/>
    <id>https://www.oldzhg.com/2020/03/23/Django-study-notes/</id>
    <published>2020-03-23T06:33:41.000Z</published>
    <updated>2022-10-08T11:36:28.719Z</updated>
    
    <content type="html"><![CDATA[<h1 id="django使用https"><a href="#django使用https" class="headerlink" title="django使用https"></a>django使用https</h1><p>使用 runserver 是不能使用 https 的</p><p>解决办法:使用 runsslserver</p><p>步骤:</p><p>1.安装:</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip <span class="keyword">install </span>django-<span class="keyword">extensions </span></span><br><span class="line">pip <span class="keyword">install </span>django-werkzeug-debugger-runserver </span><br><span class="line">pip <span class="keyword">install </span>pyOpenSSL</span><br></pre></td></tr></table></figure><p>2.启动方式</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">python manage.py runsslserver <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">8100</span> \</span><br><span class="line">--certificate /etc/pki/libvirt-spice/server-cert.pem \</span><br><span class="line">--key /etc/pki/libvirt-spice/server-key.pem </span><br><span class="line">或者</span><br><span class="line">python3 manage.py runsslserver <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">8000</span> --certificate /path/to/certificate.crt --key /path/to/key.key</span><br></pre></td></tr></table></figure><p>3.修改setting.py中的INSTALLED_APPS</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INSTALLED_APPS = (...</span><br><span class="line"><span class="string">"sslserver"</span>,</span><br><span class="line">...</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>又拍云默认屏蔽了请求源站后的跟随参数，如果配置了CDN值得注意</p><p>Django两种请求方式GET和POST</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">request</span><span class="selector-class">.GET</span><span class="selector-attr">[<span class="string">'username'</span>]</span></span><br><span class="line"><span class="selector-tag">request</span><span class="selector-class">.POST</span><span class="selector-attr">[<span class="string">'username'</span>]</span></span><br></pre></td></tr></table></figure><p>值得注意的是<strong>POST可以接受空值，而GET接受空值时会报错</strong>，可以加条件判断跳过</p><p>也可以采用下面这种方式</p><p>Try this and observe username printed: <code>http://127.0.0.1:8000/StartPage?username=test</code>.</p><p>Use <a href="https://docs.python.org/2/library/stdtypes.html#dict.get" target="_blank" rel="noopener"><code>get()</code></a> and avoid <code>MultiValueDictKeyError</code> errors:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.GET.get(<span class="string">'username'</span>, <span class="string">''</span>)</span><br></pre></td></tr></table></figure><p>后面可以设置成为空的默认参数</p><p>还有前后传参的时候不要把变量名写错了，不然会很麻烦。</p><p>看这位大佬就排除半天问题，最后仅仅是因为一个变量名的原因。</p><blockquote><p>此处之所以出错，获取不到，是因为之前同事笔误，把参数名：function_group_id，误写为了fucntion_group_id，改回来，即可正常传递参数了。</p><p>​                                                                                                                                            ———<a href="https://www.crifan.com/django_request_query_params_cannot_receive_get_para/" target="_blank" rel="noopener">引用来源</a></p></blockquote><h1 id="基于Django框架的网站部署"><a href="#基于Django框架的网站部署" class="headerlink" title="基于Django框架的网站部署"></a><a href="https://segmentfault.com/a/1190000008507042" target="_blank" rel="noopener">基于Django框架的网站部署</a></h1><h2 id="1-域名"><a href="#1-域名" class="headerlink" title="1.域名"></a>1.域名</h2><p>    首先，当我们输入一个网址<a href="http://www.example.com/时，首先经过DNS解析到对应的IP地址，从而对该IP实现访问。所以，要让别人访问我们项目的第一步，就是需要拥有两样东西，域名和公网ip。" target="_blank" rel="noopener">http://www.example.com/时，首先经过DNS解析到对应的IP地址，从而对该IP实现访问。所以，要让别人访问我们项目的第一步，就是需要拥有两样东西，域名和公网ip。</a><br>    域名的获得很简单，随便注册购买一个就好了。然后需要的是将域名解析到你的公网ip。而公网ip，一般在购买云服务器的时候能获得。<br>    经过这一步，我们实现了：请求–&gt;DNS–&gt;服务器ip，而我们的最终目的就是：请求–&gt;DNS–&gt;服务器ip–&gt;黑盒子–&gt;项目wsgi应用</p><h2 id="2-使用gunicorn运行项目"><a href="#2-使用gunicorn运行项目" class="headerlink" title="2.使用gunicorn运行项目"></a>2.使用gunicorn运行项目</h2><p>具体gunicorn 的使用可以自行google一下</p><h2 id="3-nginx接收外部请求，内部转发"><a href="#3-nginx接收外部请求，内部转发" class="headerlink" title="3.nginx接收外部请求，内部转发"></a>3.nginx接收外部请求，内部转发</h2><p>在/etc/nginx/sites-available/文件夹下，新建一个文件blog，并添加如下简单设置</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  你的域名 你的公网ip(可选);</span><br><span class="line">    <span class="attribute">access_log</span>  /var/log/nginx/blog.log;</span><br><span class="line">    <span class="attribute">location</span> /static &#123;</span><br><span class="line">        <span class="comment">#静态文件如js，css的存放目录</span></span><br><span class="line">        <span class="attribute">root</span> /project/blog;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">include</span> proxy_params;</span><br><span class="line">        <span class="comment"># 从外部接收请求后转发到本地的8000端口</span></span><br><span class="line">        <span class="attribute">proxy_pass</span> http://127.0.0.1:8000;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面我们就可以明白，nginx 接收到请求后，转发给gunicorn正在监听的本地8000端口，gunicorn根据请求调用项目中相应的应用函数后返回结果。<br>自此我们就基本实现了请求–&gt;DNS–&gt;服务器ip–&gt;nginx（80端口）–&gt;127.0.0.1：8000–&gt;项目wsgi应用<br>而关于nginx和gunicorn的具体配置还有许多，不妨多google一下延伸学习</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h2><p>gunicorn让项目跑起来<br>nginx负责接收请求和转发请求到运行中项目监听请求的端口<br>部署到线上，主要需要域名，公网ip，二者均可以通过云服务器来解决，所以最好还是直接买个云服务器实践一下，just do it</p><p>Python3 同级目录直接import</p><p>不同级目录</p><p>from 目录 import 文件</p><p>ls | grep -v .mp4 | xargs rm -r</p><h2 id="捕获url参数"><a href="#捕获url参数" class="headerlink" title="捕获url参数"></a>捕获url参数</h2><p>进行url匹配时 把需要捕获的部分设置成正则表达式的组<br>Django框架 会自动把组内参数传递给对应视图函数</p><h3 id="1-位置参数-要求顺序"><a href="#1-位置参数-要求顺序" class="headerlink" title="1.位置参数 (要求顺序)"></a>1.位置参数 (要求顺序)</h3><p>使用正则位置参数 视图的形参名可以随意指定<br><code>re_path(r&quot;index(\d+)&quot;, views.index)</code><br>(\d+)内的参数将被传递给index视图函数的形参</p><p>给位置参数必须数量一致，路由中有几个正则组，视图函数中就应该有几个形参，包含自带request参数</p><p>request 包含 用户通过浏览器请求的参数</p><h3 id="2-关键字参数-（可以指定顺序）"><a href="#2-关键字参数-（可以指定顺序）" class="headerlink" title="2.关键字参数 （可以指定顺序）"></a>2.关键字参数 （可以指定顺序）</h3><p><code>re_path(r&quot;index(?P&lt;name&gt;\d+)&quot;, views.index)</code><br><code>(?P&lt;name&gt;\d+)</code>内的参数通过关键字参数传递给视图函数<br>视图函数必须以name命名形参，也就是命名必须一致，此时参数顺序不要求</p><p><strong>小结：</strong>在url正则表达式通过’()‘来匹配传递的参数，如<code>’(\w+)&#39;</code>代表匹配字符串，然后在视图函数的形参中加入对应数量的参数（必须在视图函数的形参中接收），即可在后台接收到传入的参数，他会根据对应的顺序依次赋值。当然我们也可以在匹配参数过程中指定对应的形参名称，如：</p><p><code>url(r&#39;^params_test_reg/str(?P&lt;str&gt;\w+)page(?P&lt;page&gt;\d+)/$&#39;,params_test_reg),</code></p><p>**位置参数与关键字参数不能混用，但是用了一个位置参数时，要求剩下的必须都是位置参数，否则出现 <code>missing 1 required positional argument:</code>错误。</p><p><code>request</code>是一个<code>HttpRquest</code>类型的对象</p><p>request参数是一个WSGIRequest对象<br>WSGIRequest 对象属于django.core.handlers.wsgi.WSGIRequest<br>request对象包含浏览器请求的信息 是将WISG协议中传递给框架的env信息的再次封装</p><h4 id="WSGIRequest对象的属性"><a href="#WSGIRequest对象的属性" class="headerlink" title="WSGIRequest对象的属性"></a>WSGIRequest对象的属性</h4><p><strong>request.path</strong>: 返回字符串 表示请求的路径 不包含域名和参数部分<br><strong>request.method</strong>: 返回字符串 表示HTTP请求的方式 如: “GET” “POST”<br><strong>request.encoding</strong>: 返回字符串 表示请求的编码格式 如果为None表示使用浏览器默认设置utf-8 <strong>注意:这个属性不是只读的如果修改 接下来对属性的访问使用新的encoding值</strong></p><p>可以在templates下新建404.html 和 500.html<br>将使用此模板替代默认404页面、500页面</p><h4 id="QueryDict对象"><a href="#QueryDict对象" class="headerlink" title="QueryDict对象"></a>QueryDict对象</h4><p>WSGIRequest 对象的GET 和POST 属性用来取值<br>request.GET 或 request.POST 是一个 QueryDict 对象<br>QueryDict 对象属于 django.http.request.QueryDict</p><h4 id="创建QueryDict对象"><a href="#创建QueryDict对象" class="headerlink" title="创建QueryDict对象"></a>创建QueryDict对象</h4><p>q = QueryDict(“a=1&amp;a=2&amp;b=3”)</p><h4 id="对QueryDict对象取值"><a href="#对QueryDict对象取值" class="headerlink" title="对QueryDict对象取值"></a>对QueryDict对象取值</h4><p>q[“a”] 返回一个字符串<br>q.get(“b”) 返回一个字符串<br>q.getlist(“a”) 返回一个列表<br>如果取值不存在的键 使用[]取值会报错KeyError 使用get() 返回None 使用getlist 返回空列表</p><h4 id="get-方法设置默认值"><a href="#get-方法设置默认值" class="headerlink" title="get()方法设置默认值"></a>get()方法设置默认值</h4><p>q.get(“d”, “default”) 如果没有d这个Key 会返回字符串default<br>q.getlist(“d”, [1, “2”]) 如果没有d 这个Key 会返回列表[1, “2”]</p><h4 id="QueryDict与普通字典的区别"><a href="#QueryDict与普通字典的区别" class="headerlink" title="QueryDict与普通字典的区别"></a>QueryDict与普通字典的区别</h4><p>QueryDict的Key可以对应多个值<br>q = queryDict(“a=1&amp;a=2&amp;a=3”)<br>用[]和get()取值有多个值的QueryDict对象时 只返回最后一个Key的值<br>q[“a”] 返回 3<br>q.get(“a”) 返回 3<br>如果要对QueryDict取值Key对应的所有值 使用getlist()方法<br>q.getlist(“a”) 返回一个列表[“1”, “2”, “3”]</p><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>Cookie 在访问网站时服务器生成的储存在浏览器的一段文本信息<br>Django中cookie中的值只以字符串形式储存<br>访问服务器时服务器设置一个cookie key为要保存的id值为要保存的信息<br>将cookie发送给浏览器浏览器保存在本地<br>访问服务器时浏览器发送cookie 服务器通过cookie的id取出信息用来判断状态</p><h4 id="Cookie的特点"><a href="#Cookie的特点" class="headerlink" title="Cookie的特点"></a>Cookie的特点</h4><p>request.COOKIES是一个普通的Python字典<br>1.以键值对的方式存储 并且只储存字符串类型的值<br>2.通过浏览器访问网站时 浏览器会将所有跟这个网站相关的Cookie发送给网站<br>3.基于域名安全(不会将其他网站的cookie发给不相关的网站)<br>4.有过期时间 如果不指定时间 默认关闭浏览器后cookie就会过期设置cookie</p><p>通过HttpResponse类的对象或者它的子类的对象<br>使用对象.set_cookie()设置cookie<br>对象.set_cookie(“key”, value, max_age)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">response = HttpResponse(<span class="string">"设置cookie"</span>)</span><br><span class="line">response.set_cookie(<span class="string">"num"</span>, 1)</span><br><span class="line">renturn response</span><br></pre></td></tr></table></figure><p>实际是服务器在ResponseHeader里设置了Set-Cookie的值<br>浏览器发现Set-Cookie的值后会在本地存储对应的cookie</p><h4 id="读取cookie"><a href="#读取cookie" class="headerlink" title="读取cookie"></a>读取cookie</h4><p>通过HttpRequest类的对象或者它的子类的对象<br>使用对象.COOKIES[]读取cookie<br>对象.COOKIES[“key”]</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cookie = request.Cookie[<span class="string">"num"</span>]</span><br><span class="line"><span class="keyword">return</span> HttpResponse(cookie)</span><br></pre></td></tr></table></figure><p>在读取cookie时 实际是浏览器在RequsetHeader里设置了Cookie的值<br>浏览器将本地保存的有关这个网站的cookie保存在Cookie全部发送给服务器</p><h4 id="Cookie的寿命"><a href="#Cookie的寿命" class="headerlink" title="Cookie的寿命"></a>Cookie的寿命</h4><p>浏览器在保存cookie时默认当浏览器关闭时使cookie过期<br>response.set_cookie(max_age= , expirse= )<br>max_age= 以秒为单位设置cookie过期时间<br>expirse= 以到期日期计算cookie过期时间</p><h2 id="session"><a href="#session" class="headerlink" title="session"></a>session</h2><p>Django的session中可以储存任意类型的数据<br>所有的session信息储存在服务器数据库中的session表中<br>表的主键叫做session_key唯一标示session在表中的位置<br>表的值叫做 session_data储存了设置的session键值对<br>过期时间叫做expire_date储存了session过期日期<br>访问服务器时服务器设置session为数据表创建记录<br>服务器发送一个key为sessionid，值为session_key的cookie给浏览器<br>访问时服务器通过key为sessionid的cookie获得session_key<br>后台再通过session_key在数据库中获得session_data</p><h4 id="session特点"><a href="#session特点" class="headerlink" title="session特点"></a>session特点</h4><p>1.以键值对的方式存储 并且可以储存<strong>任意类型</strong>的值<br>2.依赖于cookie 唯一标识码sessionid就是cookie的key session_key就是cookie的值<br>3.有过期时间 如果不指定 默认两周时间</p><h4 id="设置session"><a href="#设置session" class="headerlink" title="设置session"></a>设置session</h4><p>通过HttpRequest对象的session属性设置和读取session信息<br>保存时类似于给字典添加键值对<br>对象.session[“key”] = value</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.session[<span class="string">"username"</span>] = <span class="string">"smart"</span></span><br></pre></td></tr></table></figure><h4 id="读取session"><a href="#读取session" class="headerlink" title="读取session"></a>读取session</h4><p>通过HttpRequset对象的session属性读取session信息<br>取值和没有值时的默认值<br>username = 对象.session[“username”]<br>username = 对象.session.get(“key”, 默认值)</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">username = request.session[<span class="string">"username"</span>]</span><br><span class="line">username = request.session.<span class="keyword">get</span>(<span class="string">"username"</span>, <span class="string">"没有数据"</span>)</span><br></pre></td></tr></table></figure><h4 id="session的方法"><a href="#session的方法" class="headerlink" title="session的方法"></a>session的方法</h4><p>session_data在数据表中的状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4b662403cdb5656fdba155811da63a59046fe33a:&#123;<span class="string">"username"</span>:<span class="string">"smart"</span>,<span class="string">"password"</span>:<span class="string">"passwd"</span>&#125;</span><br></pre></td></tr></table></figure><p>删除session值的部分 也就是session_data中括号中的部分<br>对象.session.clear()<br>删除session整条数据 也就是session_data对应的整条数据表记录<br>对象.session.flush()<br>删除session中指定的键值对<br>del 对象.session[“key”]<br>判断session中是否有对应的key<br>对象.session.has_key(“key”)<br>设置会话的超时时间<br>如果不设置值则等同于设置为None<br>对象.session.set_expory(value)</p><ul><li>如果value是一个整数，sessionid的cookie将在value秒后过 session也会在value秒后过期</li><li>如果value为0，sessionid的cookie浏览器关闭时过期 session会在两周后过期</li><li>如果value为None，sessionid的cookie两周后过期 session也会在两周后过期</li></ul><h2 id="cookie和session的应用场景"><a href="#cookie和session的应用场景" class="headerlink" title="cookie和session的应用场景"></a>cookie和session的应用场景</h2><p>cookie: 记住用户名 安全性要求不高<br>session: 银行卡账户 密码 涉及到安全性比较高的数据</p><p><strong>注意：</strong>要使用session还需要密匙种子SECRET_KEY，在app初始化添加进去既可以(app.config[SECRT_KEY] = ‘123WER1245erwrwe&amp;<em>%W34@##</em>&amp;@!)</p><h3 id="日志记录"><a href="#日志记录" class="headerlink" title="日志记录"></a>日志记录</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">logger = logging.getLogger(<span class="string">'django'</span>)</span><br><span class="line">logger = logging.getLogger(<span class="string">"console"</span>)</span><br><span class="line">logger.debug(<span class="string">"hello"</span>)</span><br><span class="line">logger.info(<span class="string">'This is an error msg'</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;django使用https&quot;&gt;&lt;a href=&quot;#django使用https&quot; class=&quot;headerlink&quot; title=&quot;django使用https&quot;&gt;&lt;/a&gt;django使用https&lt;/h1&gt;&lt;p&gt;使用 runserver 是不能使用 https 的
      
    
    </summary>
    
    
      <category term="工具技巧" scheme="https://www.oldzhg.com/categories/%E5%B7%A5%E5%85%B7%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="Tech" scheme="https://www.oldzhg.com/tags/Tech/"/>
    
  </entry>
  
  <entry>
    <title>如何在Mac上禁止ip</title>
    <link href="https://www.oldzhg.com/2020/03/20/How-to-forbid-an-ip-on-Mac/"/>
    <id>https://www.oldzhg.com/2020/03/20/How-to-forbid-an-ip-on-Mac/</id>
    <published>2020-03-20T10:34:14.000Z</published>
    <updated>2022-10-08T11:36:28.719Z</updated>
    
    <content type="html"><![CDATA[<p> 最近需要在Mac上禁止几个IP的通过，在网上搜到大部分都是通过编辑hosts文件禁用域名的访问。</p><p>经过一发查找后发现可以通过Mac上的pf服务达到禁用的目的。</p><p>具体pf的命令通过手册查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man pfctl</span><br></pre></td></tr></table></figure><p>首先用root 权限修改 <code>/etc/sysctl.conf</code> 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/pf.conf</span><br></pre></td></tr></table></figure><p>不用看里面的内容，在最下面添加以下文本，记得替换成你想屏蔽的ip：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 屏蔽ip</span></span><br><span class="line">block drop from any to 17.253.114.253</span><br><span class="line">block drop from any to 131.6.76.53</span><br></pre></td></tr></table></figure><p>使用-f命令为pf服务启动指定的conf文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo pfctl -f file</span><br><span class="line"><span class="comment">#Load the rules contained in file.  This file may contain macros, tables, options, and normalization, queueing, translation, and filtering rules.</span></span><br></pre></td></tr></table></figure><p>使用 <code>-e</code> 命令启用 pf 服务。使用 <code>-E</code> 命令强制重启 pf 服务，使用 <code>-d</code> 命令关闭 pf。</p><p>现在我们启动pf服务</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pfctl -ef <span class="regexp">/etc/</span>pf.conf</span><br></pre></td></tr></table></figure><p>此时发现再去ping这几个ip已经ping不通了</p><p><img src="//pic.oldzhg.com/uPic/syEbA6.png" alt=""></p><p>从 Mavericks 起 pf 服务不再默认开机自启。</p><p>如果我们想实现开机自动启动该服务，首先需要关闭系统的SIP，网上有很多方法，这里不再赘述。</p><p>然后修改 <code>/System/Library/LaunchDaemons/com.apple.pfctl.plist</code> </p><p>当尝试编辑该文件时发现系统是不可读状态，原因是从macOS 10.15开始系统将默认被挂载为只读。</p><p><img src="//pic.oldzhg.com/uPic/4GbGTH.png" alt=""></p><p>文件详细里面多了一条restricted，被限制写的操作。</p><p>还好还有另外的方法，以读写模式重新挂载系统即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo mount -uw /  </span><br><span class="line">killall Finder</span><br></pre></td></tr></table></figure><p>随后重新打开向 plist 文件中添加 <code>-e</code> 行，如下所示：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">&lt;string&gt;</span>pfctl<span class="params">&lt;/string&gt;</span></span><br><span class="line"><span class="params">&lt;string&gt;</span>-e<span class="params">&lt;/string&gt;</span></span><br><span class="line"><span class="params">&lt;string&gt;</span>-f<span class="params">&lt;/string&gt;</span></span><br><span class="line"><span class="params">&lt;string&gt;</span><span class="meta-keyword">/etc/</span>pf.conf<span class="params">&lt;/string&gt;</span></span><br></pre></td></tr></table></figure><p>下次系统启动时可以自动启动pf服务。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; 最近需要在Mac上禁止几个IP的通过，在网上搜到大部分都是通过编辑hosts文件禁用域名的访问。&lt;/p&gt;
&lt;p&gt;经过一发查找后发现可以通过Mac上的pf服务达到禁用的目的。&lt;/p&gt;
&lt;p&gt;具体pf的命令通过手册查看：&lt;/p&gt;
&lt;figure class=&quot;highligh
      
    
    </summary>
    
    
      <category term="工具技巧" scheme="https://www.oldzhg.com/categories/%E5%B7%A5%E5%85%B7%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="Tech" scheme="https://www.oldzhg.com/tags/Tech/"/>
    
  </entry>
  
  <entry>
    <title>在 macOS 中使用 GPG 密钥提交代码至 Github</title>
    <link href="https://www.oldzhg.com/2020/03/20/Commit-the-code-to-Github-with-the-GPG-key-in-macOS/"/>
    <id>https://www.oldzhg.com/2020/03/20/Commit-the-code-to-Github-with-the-GPG-key-in-macOS/</id>
    <published>2020-03-20T06:36:11.000Z</published>
    <updated>2022-10-08T11:36:28.719Z</updated>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>普通的 HTTPS 和 RSA 密钥方式提交代码，并不能判断是谁提交的代码，多人可以使用同一套验证进行提交，而 GPG 密钥就可以避免此问题，可以对提交者进行验证。</p><h2 id="创建密钥"><a href="#创建密钥" class="headerlink" title="创建密钥"></a>创建密钥</h2><h3 id="安装工具"><a href="#安装工具" class="headerlink" title="安装工具"></a>安装工具</h3><p>macOS 上创建密钥需要安装 GPG 命令行工具或者 GUI 工具，下载地址：<a href="https://www.vvave.net/go/aHR0cHM6Ly9ncGd0b29scy5vcmcv" target="_blank" rel="noopener">点击跳转</a>。安装完成后即可使用终端生成 GPG 密钥</p><h3 id="生成密钥对"><a href="#生成密钥对" class="headerlink" title="生成密钥对"></a>生成密钥对</h3><p>创建一个 GPG 密钥对，因为 GPG 有多个版本，因此可能需要查阅官方的支持手册来获得适用的命令，GitHub 适用的密钥必须适用 RSA 密钥且具有 4096 位长度。</p><ul><li>如果使用的是 2.1.17 及以后版本，可以使用下述命令进行生成。</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gpg --full-<span class="keyword">generate</span>-key</span><br></pre></td></tr></table></figure><ul><li>如果使用的不是 2.1.17 及以后的版本，可使用以下命令。</li></ul><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gpg --<span class="keyword">default</span>-<span class="keyword">new</span>-<span class="built_in">key</span>-algo rsa4096 --gen-<span class="built_in">key</span></span><br></pre></td></tr></table></figure><ol><li>然后根据屏幕提示确认使用的加密方式，默认为 RSA 。接下来确认密钥对强度，选择为 4096。</li><li>输入用户的信息并进行确认。</li><li>输入个安全的密码。</li></ol><h3 id="查看密钥对"><a href="#查看密钥对" class="headerlink" title="查看密钥对"></a>查看密钥对</h3><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">$</span> <span class="comment">gpg</span> --<span class="comment">list</span><span class="literal">-</span><span class="comment">secret</span><span class="literal">-</span><span class="comment">keys</span> --<span class="comment">keyid</span><span class="literal">-</span><span class="comment">format</span> <span class="comment">LONG</span></span><br></pre></td></tr></table></figure><p>从列表中即可看到本机存在的全部 GPG 密钥对，假定以 ID 为 3AA5C34371567BD2 的密钥对为例。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ gpg --list-secret-keys --keyid-format LONG</span><br><span class="line">/Users/hubot/.gnupg/secring.gpg</span><br><span class="line">------------------------------------</span><br><span class="line">sec   <span class="number">4096</span>R/<span class="number">3</span>AA5C34371567BD2 <span class="number">2016</span><span class="number">-03</span><span class="number">-10</span> [expires: <span class="number">2017</span><span class="number">-03</span><span class="number">-10</span>]</span><br><span class="line">uid                          Hubot </span><br><span class="line">ssb   <span class="number">4096</span>R/<span class="number">42</span>B317FD4BA89E7A <span class="number">2016</span><span class="number">-03</span><span class="number">-10</span></span><br></pre></td></tr></table></figure><p>导出密钥对信息</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">$</span> <span class="comment">gpg</span> --<span class="comment">armor</span> --<span class="comment">export</span> <span class="comment">3AA5C34371567BD2</span></span><br></pre></td></tr></table></figure><blockquote><p>小贴士：密钥对信息会以 <code>-----BEGIN PGP PUBLIC KEY BLOCK-----</code> 字符串开头，以 <code>-----END PGP PUBLIC KEY BLOCK-----</code> 字符串结束。</p></blockquote><h2 id="添加密钥"><a href="#添加密钥" class="headerlink" title="添加密钥"></a>添加密钥</h2><p>将复制出来的密钥串粘贴至 GitHub 的密钥页面中，<a href="https://www.vvave.net/go/aHR0cHM6Ly9naXRodWIuY29tL3NldHRpbmdzL2tleXM=" target="_blank" rel="noopener">点击跳转</a>。</p><h2 id="提交代码"><a href="#提交代码" class="headerlink" title="提交代码"></a>提交代码</h2><p>查看本地密钥对</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">$</span> <span class="comment">gpg</span> --<span class="comment">list</span><span class="literal">-</span><span class="comment">secret</span><span class="literal">-</span><span class="comment">keys</span> --<span class="comment">keyid</span><span class="literal">-</span><span class="comment">format</span> <span class="comment">LONG</span></span><br></pre></td></tr></table></figure><p>为本地仓库配置 GPG 密钥</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git<span class="built_in"> config </span>--global user.signingkey 3AA5C34371567BD2</span><br></pre></td></tr></table></figure><blockquote><p>小贴士：本文以 <code>3AA5C34371567BD2</code> 为例，请输入真实的密钥对 ID。</p></blockquote><p>为当前的项目配置密钥认证</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git<span class="built_in"> config </span>commit.gpgsign <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>为全部项目配置密钥认证</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git<span class="built_in"> config </span>--global commit.gpgsign <span class="literal">true</span></span><br></pre></td></tr></table></figure><blockquote><p>小贴士：配置后使用提交命令即可在 GitHub 网页中看到 出现 <strong>Verified</strong> 绿色标记。</p></blockquote><p>–</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.vvave.net/go/aHR0cHM6Ly9oZWxwLmdpdGh1Yi5jb20vZW4vYXJ0aWNsZXMvZ2VuZXJhdGluZy1hLW5ldy1ncGcta2V5" target="_blank" rel="noopener">Generating a new GPG key - GitHub Help</a></li><li><a href="https://www.vvave.net/go/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTEwNTQzMzMvYXJ0aWNsZS9kZXRhaWxzLzgzOTM0MzA5" target="_blank" rel="noopener">使用 GPG 密钥验证 Github 提交 - CSDN</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;普通的 HTTPS 和 RSA 密钥方式提交代码，并不能判断是谁提交的代码，多人可以使用同一套验证进行提交，而 GPG 密钥就可以避免此问题，可以对提交者进
      
    
    </summary>
    
    
      <category term="工具技巧" scheme="https://www.oldzhg.com/categories/%E5%B7%A5%E5%85%B7%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="Tech" scheme="https://www.oldzhg.com/tags/Tech/"/>
    
  </entry>
  
  <entry>
    <title>更改文件 md5</title>
    <link href="https://www.oldzhg.com/2020/03/19/Linux-change-file-md5/"/>
    <id>https://www.oldzhg.com/2020/03/19/Linux-change-file-md5/</id>
    <published>2020-03-19T10:34:14.000Z</published>
    <updated>2022-10-08T11:36:28.720Z</updated>
    
    <content type="html"><![CDATA[<p>大家都知道，在我们上传文件到百度云时，他会先读取文件的md5值。</p><p>如果该md5在他的数据库中，</p><p>就会直接把文件的一个软链接复制到你的云盘中，给你一种光速上传的感觉。</p><p>但是所有资源都要经过百度云的审查之后才能上传成功，否则就会有各种原因无法访问。</p><p>所以重要文件不建议放在百度云，说不定哪天你就拿不回来了。</p><p>回到正题，现在我想上传一个video到百度云上，发现之前有人上传过导致被和谐。</p><p>我们可以通过修改md5的值实现让百度以为这是另一个文件。</p><p>最安全的方法是压缩后再上传，但是有些麻烦，还不能在线播放和预览。</p><p>在window上可以通过copy这个命令合并两个文件成一个文件。</p><p>但是Linux上如何解决呢？</p><p>经过查找后，感谢v2ex，有人问过相同的问题。</p><p>其实只要在文件末尾后面加二进制的00即可，既不会改变文件的大概性质，还实现了修改md5。</p><p>以a.txt演示，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e -n <span class="string">"\x00"</span> &gt;&gt; 你的文件</span><br></pre></td></tr></table></figure><p>演示效果如下：</p><p><img src="//pic.oldzhg.com/uPic/aeHTVL.png" alt=""></p><p>批量修改当前文件夹下所有文件md5值的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -<span class="built_in">type</span> f -<span class="built_in">exec</span> bash -c <span class="string">'echo -e -n "\x00" &gt;&gt; &#123;&#125;'</span> \;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;大家都知道，在我们上传文件到百度云时，他会先读取文件的md5值。&lt;/p&gt;
&lt;p&gt;如果该md5在他的数据库中，&lt;/p&gt;
&lt;p&gt;就会直接把文件的一个软链接复制到你的云盘中，给你一种光速上传的感觉。&lt;/p&gt;
&lt;p&gt;但是所有资源都要经过百度云的审查之后才能上传成功，否则就会有各种原
      
    
    </summary>
    
    
    
      <category term="Tech" scheme="https://www.oldzhg.com/tags/Tech/"/>
    
  </entry>
  
  <entry>
    <title>VPS上安装rclone实现挂载谷歌云盘</title>
    <link href="https://www.oldzhg.com/2020/03/15/rclone-use/"/>
    <id>https://www.oldzhg.com/2020/03/15/rclone-use/</id>
    <published>2020-03-15T10:34:14.000Z</published>
    <updated>2022-10-08T11:36:28.722Z</updated>
    
    <content type="html"><![CDATA[<h2 id="rclone安装"><a href="#rclone安装" class="headerlink" title="rclone安装"></a>rclone安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">curl https://rclone.org/install.sh | bash</span><br><span class="line"></span><br><span class="line">rclone config</span><br><span class="line"></span><br><span class="line"><span class="comment">#新建本地文件夹，路径自己定，即下面的LocalFolder</span></span><br><span class="line">mkdir /root/GoogleDrive</span><br><span class="line"><span class="comment">#挂载为磁盘，下面的DriveName、Folder、LocalFolder参数根据说明自行替换</span></span><br><span class="line">rclone mount DriveName:Folder LocalFolder --copy-links --no-gzip-encoding --no-check-certificate --allow-other --allow-non-empty --<span class="built_in">umask</span> 000 &amp;</span><br><span class="line"></span><br><span class="line">rclone mount Kid:/ /data/wwwroot/directory/GoogleDrive --copy-links --no-gzip-encoding --no-check-certificate --allow-other --allow-non-empty --<span class="built_in">umask</span> 000 &amp;</span><br><span class="line"></span><br><span class="line"><span class="comment">#卸载</span></span><br><span class="line">fusermount -qzu LocalFolder</span><br></pre></td></tr></table></figure><h2 id="开启自启动"><a href="#开启自启动" class="headerlink" title="开启自启动"></a>开启自启动</h2><p>先新建<code>systemd</code>配置文件，适用<code>CentOS 7</code>、<code>Debian 8+</code>、<code>Ubuntu 16+</code>。</p><p>再使用命令：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将后面修改成你上面手动运行命令中，除了rclone的全部参数</span></span><br><span class="line"><span class="attribute">command</span>=<span class="string">"mount DriveName:Folder LocalFolder --copy-links --no-gzip-encoding --no-check-certificate --allow-other --allow-non-empty --umask 000"</span></span><br><span class="line"><span class="comment">#以下是一整条命令，一起复制到SSH客户端运行</span></span><br><span class="line">cat &gt; /etc/systemd/system/rclone.service &lt;&lt;EOF</span><br><span class="line">[Unit]</span><br><span class="line"><span class="attribute">Description</span>=Rclone</span><br><span class="line"><span class="attribute">After</span>=network-online.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line"><span class="attribute">Type</span>=simple</span><br><span class="line"><span class="attribute">ExecStart</span>=$(command -v rclone) <span class="variable">$&#123;command&#125;</span></span><br><span class="line"><span class="attribute">Restart</span>=on-abort</span><br><span class="line"><span class="attribute">User</span>=root</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line"><span class="attribute">WantedBy</span>=default.target</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>开始启动：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="literal">start</span> rclone</span><br></pre></td></tr></table></figure><p>设置开机自启：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="builtin-name">enable</span> rclone</span><br></pre></td></tr></table></figure><p>其他命令：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">重启：systemctl restart rclone</span><br><span class="line">停止：systemctl <span class="keyword">stop</span> rclone</span><br><span class="line">状态：systemctl <span class="keyword">status</span> rclone</span><br></pre></td></tr></table></figure><p>如果你想挂载多个网盘，那么将<code>systemd</code>配置文件的<code>rclone.service</code>改成<code>rclone1.service</code>即可，重启动什么的同样换成<code>rclone1</code>。</p><h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><ul><li>别把挂载盘当下载目录，可以下载到其它目录后，移动进挂载盘</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;rclone安装&quot;&gt;&lt;a href=&quot;#rclone安装&quot; class=&quot;headerlink&quot; title=&quot;rclone安装&quot;&gt;&lt;/a&gt;rclone安装&lt;/h2&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cla
      
    
    </summary>
    
    
    
      <category term="Tech" scheme="https://www.oldzhg.com/tags/Tech/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统下实现远程连接MySQL数据库的方法教程</title>
    <link href="https://www.oldzhg.com/2020/03/13/Linux-connect-Mysql-remote/"/>
    <id>https://www.oldzhg.com/2020/03/13/Linux-connect-Mysql-remote/</id>
    <published>2020-03-13T11:33:30.000Z</published>
    <updated>2022-10-08T11:36:28.720Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h3><p>最近在工作中遇到了这个需求，估计搞了一个多小时才把这个远程连接搞好。一台本地电脑，一台云服务器，都是linux系统。下面来看看详细的介绍：</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a><strong>步骤</strong></h3><h4 id="1、在服务器端开启远程访问"><a href="#1、在服务器端开启远程访问" class="headerlink" title="1、在服务器端开启远程访问"></a><strong>1、在服务器端开启远程访问</strong></h4><p>首先进入mysql数据库，然后输入下面两个命令：  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grant all privileges on *.* to <span class="string">'root'</span>@<span class="string">'%'</span> identified by <span class="string">'你的密码'</span>;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><p>第一个*是数据库，可以改成允许访问的数据库名称  </p><p>第二个 是数据库的表名称，代表允许访问任意的表  </p><p>root代表远程登录使用的用户名，可以自定义  </p><p>%代表允许任意ip登录，如果你想指定特定的IP，可以把%替换掉就可以了  </p><p><strong>password代表远程登录时使用的密码，可以自定义</strong>  </p><p>flush privileges;这是让权限立即生效  </p><h4 id="2、修改my-cnf配置文件"><a href="#2、修改my-cnf配置文件" class="headerlink" title="2、修改my.cnf配置文件"></a><strong>2、修改my.cnf配置文件</strong></h4><p>这个是mysql的配置文件，如果你找不到在哪里的话，可以输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`find /* -name my.cnf`</span><br></pre></td></tr></table></figure><p>通过vim编辑该文件，找到<code>bind-address    = 127.0.0.1 或者是 0.0.0.0</code>这一句</p><p>然后在前面加个#号注释掉，保存退出</p><h4 id="3、重启服务"><a href="#3、重启服务" class="headerlink" title="3、重启服务"></a><strong>3、重启服务</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mysql restart</span><br></pre></td></tr></table></figure><h4 id="4、在本地远程连接"><a href="#4、在本地远程连接" class="headerlink" title="4、在本地远程连接"></a><strong>4、在本地远程连接</strong></h4><p>在终端输入：  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h 服务器ip地址 -P 3306 -u root -p</span><br></pre></td></tr></table></figure><p>然后输入密码即可。  </p><p>root是第1点设置的用户名，密码也是第1点设置的密码  , 注意第一个P指定端口是大写</p><h3 id="一些细节"><a href="#一些细节" class="headerlink" title="一些细节"></a><strong>一些细节</strong></h3><p>在网上找了很多文章，说要开启3306端口才能连接，但是我开启了却还是无法连接，后来又找到了一些文章，说要更改my.cnf，也就是上面的第2点，更改了然后重启服务器就可以了。</p><p>刚刚在另外一台服务器上面试了一下，没有配置过端口，通过上面三步，很快就连上了。</p><p>所以第二点非常重要，基本上每个人装mysql的时候都会去配置那个文件，因为字符集需要配置。所以肯定有那个文件的，用find命令找找就行了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;最近在工作中遇到了这个需求，估计搞了一个多小时才把这个远程连接搞好。一台本地电脑，一台云服务器，都是lin
      
    
    </summary>
    
    
    
      <category term="Tech" scheme="https://www.oldzhg.com/tags/Tech/"/>
    
  </entry>
  
  <entry>
    <title>iTerm2连接VPS上查看中文乱码</title>
    <link href="https://www.oldzhg.com/2020/03/12/%20iTerm2-Connect-Remote-Host%20Chinese-Garbled/"/>
    <id>https://www.oldzhg.com/2020/03/12/%20iTerm2-Connect-Remote-Host%20Chinese-Garbled/</id>
    <published>2020-03-12T10:34:14.000Z</published>
    <updated>2022-10-08T11:36:28.718Z</updated>
    
    <content type="html"><![CDATA[<p>mac 上用是iterm2终端, Shell 环境是zsh。ssh 到Linux 服务器上查看一些文件时，中文乱码。  这种情况一般是终端和服务器的字符集不匹配，MacOSX下默认的是utf8字符集。</p><p>解决方案如下：<br>输入locale可以查看字符编码设置情况，而我的对应值是空的。  而默认的.zshrc没有设置为utf-8编码，所以本地和服务器端都要在.zshrc设置，步骤如下，(bash对应.bash_profile或.bashrc文件)。</p><p>1.在终端下输入  </p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~<span class="string">/.zshrc</span></span><br></pre></td></tr></table></figure><p>2.在文件内容末端添加：  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> LC_ALL=en_US.UTF-8</span><br><span class="line"><span class="built_in">export</span> LANG=en_US.UTF-8</span><br></pre></td></tr></table></figure><p>接着重启一下终端，或者输入source ~/.zshrc使设置生效。  </p><p>连接服务器，中文显示都正常了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;mac 上用是iterm2终端, Shell 环境是zsh。ssh 到Linux 服务器上查看一些文件时，中文乱码。  这种情况一般是终端和服务器的字符集不匹配，MacOSX下默认的是utf8字符集。&lt;/p&gt;
&lt;p&gt;解决方案如下：&lt;br&gt;输入locale可以查看字符编码设置
      
    
    </summary>
    
    
    
      <category term="Tech" scheme="https://www.oldzhg.com/tags/Tech/"/>
    
  </entry>
  
  <entry>
    <title>保持ssh不自动断开</title>
    <link href="https://www.oldzhg.com/2020/03/09/prevent-ssh-auto-disconnect/"/>
    <id>https://www.oldzhg.com/2020/03/09/prevent-ssh-auto-disconnect/</id>
    <published>2020-03-09T10:34:14.000Z</published>
    <updated>2022-10-08T11:36:28.722Z</updated>
    
    <content type="html"><![CDATA[<p>在mac上ssh自己的服务器后总是会断开，比如wget某一个东西，或者tar一个大文件，如果你总是受此困扰，不妨尝试一下此文里的配置。</p><p>其实ssh已经考虑到了此问题，但是可能考虑到安全和资源占用等因素，默认没有启用，现在我们把它打开。</p><h2 id="服务端设置"><a href="#服务端设置" class="headerlink" title="服务端设置"></a>服务端设置</h2><p>找到<code>/etc/ssh/sshd_config</code>，大约126-127行，取消注释，并修改数值</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">30</span>表示<span class="number">30</span>s给客户端发送一次心跳</span><br><span class="line">ClientAliveInterval <span class="number">30</span></span><br><span class="line"># <span class="number">3</span>此客户端没有返回心跳，则会断开连接</span><br><span class="line">ClientAliveCountMax <span class="number">3</span></span><br></pre></td></tr></table></figure><h2 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h2><p>如果是想让主机所有用户都生效，修改<code>/etc/ssh/ssh_config</code><br>如果只想让本人生效，则修改 <code>~/.ssh/config</code></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Host</span> <span class="string">*</span></span><br><span class="line">    <span class="attr">ServerAliveInterval</span> <span class="string">30</span></span><br><span class="line">    <span class="attr">ServerAliveCountMax</span> <span class="string">3</span></span><br></pre></td></tr></table></figure><blockquote><p>如果此处还有一个配置项叫 SendEnv LANG LC_*，老高建议最好注释掉，否则如果本地是中文环境，而服务器没有对应的中文语言选项时系统可能会出现很多莫名其妙的BUG，所以保持原始英文语言环境为上。</p></blockquote><h2 id="一次性配置"><a href="#一次性配置" class="headerlink" title="一次性配置"></a>一次性配置</h2><p>如果只是想临时使用一次，完全可以不用大动干戈地找配置文件改，ssh命令支持直接注入参数，如下：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -o ServerAliveInterval=<span class="number">30</span> <span class="symbol">user@</span>host</span><br></pre></td></tr></table></figure><h2 id="查看是否生效"><a href="#查看是否生效" class="headerlink" title="查看是否生效"></a>查看是否生效</h2><p>想测试是否生效，我们直接ssh到服务器后等一会儿看效果就行，但是如果想看到服务器和客户端发送心跳包的过程，可以这样</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -o ServerAliveInterval=<span class="number">30</span> -vvv <span class="symbol">user@</span>host</span><br></pre></td></tr></table></figure><p>等30s后我们应该可以看到如下字样，说明我们在指定时间发送了心跳给服务器，服务器也有应答。同理如果我们在服务器也打开了心跳，则应该是先收到服务器的心跳然后再应答。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">debug3: send packet:<span class="built_in"> type </span>80</span><br><span class="line">debug3: receive packet:<span class="built_in"> type </span>82</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://bluebiu.com/blog/linux-ssh-session-alive.html" target="_blank" rel="noopener">Linux使用ssh超时断开连接的真正原因</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在mac上ssh自己的服务器后总是会断开，比如wget某一个东西，或者tar一个大文件，如果你总是受此困扰，不妨尝试一下此文里的配置。&lt;/p&gt;
&lt;p&gt;其实ssh已经考虑到了此问题，但是可能考虑到安全和资源占用等因素，默认没有启用，现在我们把它打开。&lt;/p&gt;
&lt;h2 id=&quot;
      
    
    </summary>
    
    
    
      <category term="Tech" scheme="https://www.oldzhg.com/tags/Tech/"/>
    
  </entry>
  
  <entry>
    <title>Windows7 PowerShell 2.0升级到 PowerShell 5.1</title>
    <link href="https://www.oldzhg.com/2020/03/05/Windows7%20PowerShell%202.0%20upgrade%20to%20PowerShell%205.1/"/>
    <id>https://www.oldzhg.com/2020/03/05/Windows7%20PowerShell%202.0%20upgrade%20to%20PowerShell%205.1/</id>
    <published>2020-03-05T10:34:14.000Z</published>
    <updated>2022-10-08T11:36:28.722Z</updated>
    
    <content type="html"><![CDATA[<p>两种方案可以查询：</p><ul><li><p><a href="https://docs.microsoft.com/en-us/skypeforbusiness/set-up-your-computer-for-windows-powershell/download-and-install-windows-powershell-5-1" target="_blank" rel="noopener">官方链接</a></p></li><li><p><a href="https://blog.csdn.net/xiayuexingkong/article/details/93733047" target="_blank" rel="noopener">CSDN</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;两种方案可以查询：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/skypeforbusiness/set-up-your-computer-for-windows-powershell/download
      
    
    </summary>
    
    
    
      <category term="Tech" scheme="https://www.oldzhg.com/tags/Tech/"/>
    
  </entry>
  
  <entry>
    <title>使用denyhosts防止ssh暴力破解</title>
    <link href="https://www.oldzhg.com/2020/02/24/%E4%BD%BF%E7%94%A8denyhosts%E9%98%B2%E6%AD%A2ssh%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/"/>
    <id>https://www.oldzhg.com/2020/02/24/%E4%BD%BF%E7%94%A8denyhosts%E9%98%B2%E6%AD%A2ssh%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/</id>
    <published>2020-02-24T08:48:34.000Z</published>
    <updated>2022-10-08T11:36:28.722Z</updated>
    
    <content type="html"><![CDATA[<p>配合<a href="https://zhuanlan.zhihu.com/p/36404653" target="_blank" rel="noopener">DenyHosts防御ssh暴力破解</a>阅读搭建更快</p><p><em>当你的 Linux 服务器暴露在互联网之中,该服务器将会遭到互联网上的扫描软件进行扫描,并试图猜测SSH登录口令。你会发现,每天会有多条SSH登录失败纪录。那些扫描工具将对你的服务器构成威胁,你必须设置复杂登录口令,并将尝试多次登录失败的IP给阻止掉,让其在一段时间内不能访问该服务器。</em></p><h2 id="1-denyhosts介绍"><a href="#1-denyhosts介绍" class="headerlink" title="1. denyhosts介绍"></a>1. denyhosts介绍</h2><p><code>denyhosts</code>是<code>Python</code>语言写的一个程序，它会分析<code>sshd</code>的日志文件（<code>/var/log/secure</code>），当发现重 复的攻击时就会记录<code>IP</code>到<code>/etc/hosts.deny</code>文件，从而达到自动屏<code>IP</code>的功能。</p><h2 id="2-下载和安装"><a href="#2-下载和安装" class="headerlink" title="2. 下载和安装"></a>2. 下载和安装</h2><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>wget <span class="symbol">https:</span>/<span class="regexp">/nchc.dl.sourceforge.net/project</span><span class="regexp">/denyhosts/denyhosts</span><span class="regexp">/2.6/</span>DenyHosts<span class="number">-2.6</span>.tar.gz  <span class="comment">#下载</span></span><br><span class="line"><span class="variable">$ </span>tar -zxvf DenyHosts<span class="number">-2.6</span>.tar.gz  <span class="comment">#解压</span></span><br><span class="line"><span class="variable">$ </span>cd DenyHosts<span class="number">-2.6</span> <span class="comment">#进入解压目录</span></span><br><span class="line"><span class="variable">$ </span>python setup.py install <span class="comment">#编译安装</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#拷贝和修改默认配置文件的名称</span></span><br><span class="line"><span class="variable">$ </span>cd /usr/share/denyhosts/ <span class="comment">#进入安装目录</span></span><br><span class="line"><span class="variable">$ </span>cp denyhosts.cfg-dist denyhosts.cfg</span><br><span class="line"><span class="variable">$ </span>cp daemon-control-dist daemon-control</span><br></pre></td></tr></table></figure><h2 id="3-配置"><a href="#3-配置" class="headerlink" title="3. 配置"></a>3. 配置</h2><p>此配置为可选项，因为原本就已经有默认的配置了。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#3.编辑配置文件denyhosts.cfg</span></span><br><span class="line">$ vim denyhosts.cfg   <span class="comment">#该配置文件结构比较简单，如果不想瞎折腾可以参照如下配置即可：</span></span><br><span class="line"></span><br><span class="line">PURGE_DENY = 1d       <span class="comment">#ip被禁止之后，多久可以释放(w表示周，d表示天，h表示小时，m表示分钟)</span></span><br><span class="line">DENY_THRESHOLD_INVALID = 5 <span class="comment">#无效用户名限制登陆次数</span></span><br><span class="line">DENY_THRESHOLD_VALID = 10 <span class="comment">#有效用户名限制登陆次数</span></span><br><span class="line">DENY_THRESHOLD_ROOT = 5 <span class="comment">#root限制登陆次数</span></span><br><span class="line">AGE_RESET_ROOT = 1d  <span class="comment">#root用户登录失败计数归零的时间</span></span><br></pre></td></tr></table></figure><p>更多配置说明：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">############ THESE SETTINGS ARE REQUIRED ############</span><br><span class="line">#sshd的日志文件</span><br><span class="line">SECURE_LOG = /var/log/secure </span><br><span class="line">#将阻止IP写入到hosts.deny,所以这个工具只支持 支持tcp wrapper的协议     </span><br><span class="line">HOSTS_DENY = /etc/hosts.deny </span><br><span class="line">#当一个IP被阻止以后，过多长时间被自动解禁。可选如<span class="number">3</span>m（三分钟）、<span class="number">5</span>h（<span class="number">5</span>小时）、<span class="number">2</span>d（两天）、<span class="number">8</span>w（<span class="number">8</span>周）、<span class="number">1</span>y(一年)</span><br><span class="line">PURGE_DENY = <span class="number">1</span>w </span><br><span class="line">#阻止服务名   </span><br><span class="line">BLOCK_SERVICE  = sshd</span><br><span class="line">#定义了某一IP最多被解封多少次。即某一IP由于暴力破解SSH密码被阻止/解封达到了PURGE_THRESHOLD次，则会被永久禁止；</span><br><span class="line">PURGE_THRESHOLD = <span class="number">20</span></span><br><span class="line">#允许无效用户登录失败的次数     </span><br><span class="line">DENY_THRESHOLD_INVALID = <span class="number">5</span></span><br><span class="line">#允许普通有效用户登录失败的次数   </span><br><span class="line">DENY_THRESHOLD_VALID = <span class="number">10</span>  </span><br><span class="line">#允许root登录失败的次数  </span><br><span class="line">DENY_THRESHOLD_ROOT = <span class="number">1</span>   </span><br><span class="line">#设定 deny host 写入到该资料夹   </span><br><span class="line">DENY_THRESHOLD_RESTRICTED = <span class="number">1</span></span><br><span class="line">#将deny的host或ip记录到work_dir中      </span><br><span class="line">WORK_DIR = /var/lib/denyhosts      </span><br><span class="line">SUSPICIOUS_LOGIN_REPORT_ALLOWED_HOSTS=YES</span><br><span class="line">#是否做域名反解   </span><br><span class="line">HOSTNAME_LOOKUP=YES  </span><br><span class="line">#将DenyHost启动的pid记录到LOCK_FILE中，已确保服务正确启动，防止同时启动多个服务  </span><br><span class="line">LOCK_FILE = /var/lock/subsys/denyhosts    </span><br><span class="line"></span><br><span class="line">############ THESE SETTINGS ARE OPTIONAL ############</span><br><span class="line">#设置管理员邮件地址 例如****@<span class="number">163.</span>com</span><br><span class="line">ADMIN_EMAIL = root</span><br><span class="line">SMTP_HOST = localhost</span><br><span class="line">SMTP_PORT = <span class="number">25</span></span><br><span class="line">SMTP_FROM = DenyHosts &lt;nobody@localhost&gt;</span><br><span class="line">SMTP_SUBJECT = DenyHosts Report <span class="keyword">from</span> $[HOSTNAME]</span><br><span class="line"></span><br><span class="line"># 有效用户登录失败计数归零的时间</span><br><span class="line">AGE_RESET_VALID=<span class="number">5</span>d  </span><br><span class="line"># ROOT用户登录失败计数归零的时间</span><br><span class="line">AGE_RESET_ROOT=<span class="number">25</span>d  </span><br><span class="line"># 用户的失败登录计数重置为<span class="number">0</span>的时间(/usr/share/denyhosts/restricted-usernames)</span><br><span class="line">AGE_RESET_RESTRICTED=<span class="number">25</span>d  </span><br><span class="line"># 无效用户登录失败计数归零的时间</span><br><span class="line">AGE_RESET_INVALID=<span class="number">10</span>d</span><br><span class="line"></span><br><span class="line">######### THESE SETTINGS ARE SPECIFIC TO DAEMON MODE  ##########</span><br><span class="line">#denyhost服务日志文件</span><br><span class="line">DAEMON_LOG = /var/log/denyhosts  </span><br><span class="line"></span><br><span class="line">DAEMON_SLEEP = <span class="number">30</span>s </span><br><span class="line">#该项与PURGE_DENY 设置成一样，也是清除hosts.deniedssh 用户的时间,区别是以daemon模式运行时跟PURGE_DENY配合使用，自动解禁才能生效</span><br><span class="line">DAEMON_PURGE = <span class="number">1</span>h</span><br></pre></td></tr></table></figure><h2 id="4-启动denyhosts"><a href="#4-启动denyhosts" class="headerlink" title="4.启动denyhosts"></a>4.启动denyhosts</h2><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./daemon-control <span class="literal">start</span></span><br></pre></td></tr></table></figure><p>可以使用命令<code>ps -ef | grep denyhosts</code>查看是否运行成功。如下结果表示运行成功。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="symbol">root@</span>host denyhosts]# ps -ef | grep denyhosts</span><br><span class="line">root     <span class="number">17588</span>     <span class="number">1</span>  <span class="number">0</span> <span class="number">11</span>:<span class="number">57</span> ?        <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> python /usr/bin/denyhosts.py --daemon --config=/usr/share/denyhosts/denyhosts.cfg</span><br><span class="line">root     <span class="number">17611</span> <span class="number">24100</span>  <span class="number">0</span> <span class="number">12</span>:<span class="number">07</span> pts/<span class="number">1</span>    <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> grep --color=<span class="built_in">auto</span> denyhosts</span><br><span class="line">[<span class="symbol">root@</span>host denyhosts]#</span><br></pre></td></tr></table></figure><h2 id="5-设置开机自动启动"><a href="#5-设置开机自动启动" class="headerlink" title="5.设置开机自动启动"></a>5.设置开机自动启动</h2><p>让<code>denyhosts</code>每次重启后自动启动。设置自动启动可以通过两种方法进行。</p><p>第一种是将<code>denyhosts</code>作为守护进程服务运行，这种方法可以通过<code>/etc/init.d/denyhosts</code>命令来控制其状态。方法如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd /etc/init.d</span><br><span class="line">$ ln -s /usr/share/denyhosts/daemon-control denyhosts</span><br><span class="line">$<span class="built_in"> service </span>denyhosts start</span><br></pre></td></tr></table></figure><p>或者用以下命令通过<code>chkconfig</code>工具来管理更方便。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">cd</span> <span class="string">/etc/init.d</span></span><br><span class="line">$ chkconfig <span class="params">--add</span> denyhosts</span><br><span class="line">$ chkconfig <span class="params">--level</span> 2345 denyhosts on</span><br></pre></td></tr></table></figure><p>第二种是将<code>denyhosts</code>直接加入<code>rc.local</code>中自动启动（类似于<code>Windows</code>中的“启动文件夹”）：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>echo <span class="string">'/usr/share/denyhosts/daemon-control start'</span> &gt;&gt; <span class="regexp">/etc/rc</span>.local</span><br></pre></td></tr></table></figure><p>如果想查看已经被阻止的<code>IP</code>，查看<code>/etc/hosts.deny</code> 文件即可。如下：</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@host ~]# cat /etc/hosts.deny</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># hosts.denyThis file contains access rules which are used to</span></span><br><span class="line"><span class="meta">#deny connections to network services that either use</span></span><br><span class="line"><span class="meta">#the tcp_wrappers library or that have been</span></span><br><span class="line"><span class="meta">#started through a tcp_wrappers-enabled xinetd.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#The rules in this file can also be set up in</span></span><br><span class="line"><span class="meta">#/etc/hosts.allow with a 'deny' option instead.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#See 'man 5 hosts_options' and 'man 5 hosts_access'</span></span><br><span class="line"><span class="meta">#for information on rule syntax.</span></span><br><span class="line"><span class="meta">#See 'man tcpd' for information on tcp_wrappers</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># DenyHosts: Sat Jan 12 12:22:17 2019 | sshd: 120.35.33.27</span></span><br><span class="line">sshd: <span class="number">120.35</span><span class="number">.33</span><span class="number">.27</span></span><br><span class="line">[root@host ~]#</span><br></pre></td></tr></table></figure><h2 id="6-解禁ip"><a href="#6-解禁ip" class="headerlink" title="6. 解禁ip"></a>6. 解禁ip</h2><p>编辑<code>/etc/hosts.deny</code>。然后删除或者注释掉对应的<code>sshd</code>即可。如以下用注释的方式解禁：</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@host ~]# vim /etc/hosts.deny</span><br><span class="line"><span class="meta"># hosts.denyThis file contains access rules which are used to</span></span><br><span class="line"><span class="meta">#deny connections to network services that either use</span></span><br><span class="line"><span class="meta">#the tcp_wrappers library or that have been</span></span><br><span class="line"><span class="meta">#started through a tcp_wrappers-enabled xinetd.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#The rules in this file can also be set up in</span></span><br><span class="line"><span class="meta">#/etc/hosts.allow with a 'deny' option instead.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#See 'man 5 hosts_options' and 'man 5 hosts_access'</span></span><br><span class="line"><span class="meta">#for information on rule syntax.</span></span><br><span class="line"><span class="meta">#See 'man tcpd' for information on tcp_wrappers</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># DenyHosts: Sat Jan 12 12:22:17 2019 | sshd: 120.35.33.27</span></span><br><span class="line"><span class="meta">#sshd: 120.35.33.27</span></span><br><span class="line">[root@host ~]#</span><br></pre></td></tr></table></figure><p>如果想删除一个已经禁止的主机IP,只在<code>/etc/hosts.deny</code>删除是没用的。需要进入<code>/usr/share/denyhosts/data/</code> 目录对以下文件一个个删除你想取消的主机IP才行。</p><blockquote><p>/usr/share/denyhosts/data/hosts<br>/usr/share/denyhosts/data/hosts-restricted<br>/usr/share/denyhosts/data/hosts-root<br>/usr/share/denyhosts/data/hosts-valid<br>/usr/share/denyhosts/data/users-hosts</p></blockquote><p>你可以执行命令<code>sudo grep 120.35.33.27 /usr/share/denyhosts/data/*</code>查看具体文件ip为“120.35.33.27”的具体位置</p><p>但如果这样一个有个操作确实很麻烦，不过机智的我在网上找了一个脚本(<code>denyhosts_removeip.sh</code>)，这个脚本可以快速的解决这个问题。其内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Author:licess</span></span><br><span class="line"><span class="comment"># Website:https://www.vpser.net &amp; https://lnmp.org</span></span><br><span class="line">HOST=<span class="variable">$1</span></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$&#123;HOST&#125;</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Usage:<span class="variable">$0</span> IP"</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Remove IP:<span class="variable">$&#123;HOST&#125;</span> from denyhosts..."</span></span><br><span class="line">/etc/init.d/denyhosts stop</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'</span></span><br><span class="line"><span class="string">/etc/hosts.deny</span></span><br><span class="line"><span class="string">/usr/share/denyhosts/data/hosts</span></span><br><span class="line"><span class="string">/usr/share/denyhosts/data/hosts-restricted</span></span><br><span class="line"><span class="string">/usr/share/denyhosts/data/hosts-root</span></span><br><span class="line"><span class="string">/usr/share/denyhosts/data/hosts-valid</span></span><br><span class="line"><span class="string">/usr/share/denyhosts/data/users-hosts</span></span><br><span class="line"><span class="string">'</span> | grep -v <span class="string">"^$"</span> | xargs sed -i <span class="string">"/<span class="variable">$&#123;HOST&#125;</span>/d"</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#iptables -D INPUT -s $&#123;HOST&#125; -p tcp -m tcp --dport 22 -j DROP</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">" done"</span></span><br><span class="line">/etc/init.d/denyhosts start</span><br></pre></td></tr></table></figure><p>执行脚本清除denyhosts某个IP的命令如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">bash</span> <span class="selector-tag">denyhosts_removeip</span><span class="selector-class">.sh</span> 10<span class="selector-class">.10</span><span class="selector-class">.10</span><span class="selector-class">.10</span></span><br></pre></td></tr></table></figure><p>参考教程：</p><ol><li><a href="http://coolnull.com/2068.html" target="_blank" rel="noopener">http://coolnull.com/2068.html</a></li><li><a href="https://www.spamcage.com/denyhosts.html" target="_blank" rel="noopener">https://www.spamcage.com/denyhosts.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;配合&lt;a href=&quot;https://zhuanlan.zhihu.com/p/36404653&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;DenyHosts防御ssh暴力破解&lt;/a&gt;阅读搭建更快&lt;/p&gt;
&lt;p&gt;&lt;em&gt;当你的 Linux 服务器暴露在
      
    
    </summary>
    
    
    
      <category term="Tech" scheme="https://www.oldzhg.com/tags/Tech/"/>
    
  </entry>
  
  <entry>
    <title>Centos7禁用密码登录</title>
    <link href="https://www.oldzhg.com/2020/02/18/Centos7-disable-password-login/"/>
    <id>https://www.oldzhg.com/2020/02/18/Centos7-disable-password-login/</id>
    <published>2020-02-18T10:34:14.000Z</published>
    <updated>2022-10-08T11:36:28.719Z</updated>
    
    <content type="html"><![CDATA[<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ul><li>编辑<code>/etc/ssh/sshd_config</code></li><li>将<code>PasswordAuthentication</code>参数值修改为no： <code>PasswordAuthentication no</code></li><li>重启ssh服务：<code>systemctl restart sshd.service</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;步骤&quot;&gt;&lt;a href=&quot;#步骤&quot; class=&quot;headerlink&quot; title=&quot;步骤&quot;&gt;&lt;/a&gt;步骤&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;编辑&lt;code&gt;/etc/ssh/sshd_config&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;将&lt;code&gt;PasswordAuth
      
    
    </summary>
    
    
    
      <category term="Tech" scheme="https://www.oldzhg.com/tags/Tech/"/>
    
  </entry>
  
</feed>
