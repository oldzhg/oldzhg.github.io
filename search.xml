<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>iTerm2连接VPS上查看中文乱码</title>
    <url>/2020/03/12/%20iTerm2-Connect-Remote-Host%20Chinese-Garbled/</url>
    <content><![CDATA[<p>mac 上用是iterm2终端, Shell 环境是zsh。ssh 到Linux 服务器上查看一些文件时，中文乱码。  这种情况一般是终端和服务器的字符集不匹配，MacOSX下默认的是utf8字符集。</p>
<p>解决方案如下：<br>输入locale可以查看字符编码设置情况，而我的对应值是空的。  而默认的.zshrc没有设置为utf-8编码，所以本地和服务器端都要在.zshrc设置，步骤如下，(bash对应.bash_profile或.bashrc文件)。</p>
<p>1.在终端下输入  </p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">vim ~<span class="string">/.zshrc</span></span><br></pre></td></tr></table></figure>

<p>2.在文件内容末端添加：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> LC_ALL=en_US.UTF-8</span><br><span class="line"><span class="built_in">export</span> LANG=en_US.UTF-8</span><br></pre></td></tr></table></figure>

<p>接着重启一下终端，或者输入source ~/.zshrc使设置生效。  </p>
<p>连接服务器，中文显示都正常了。</p>
]]></content>
      <tags>
        <tag>Tech</tag>
      </tags>
  </entry>
  <entry>
    <title>防盗链技术</title>
    <url>/2020/03/25/Anti-hotlinking-technology/</url>
    <content><![CDATA[<h1 id="基础防盗链"><a href="#基础防盗链" class="headerlink" title="基础防盗链"></a>基础防盗链</h1><p>主要是对客户端请求所携带的一些关键信息来验证请求的合法性，比如客户端请求IP，请求URL中携带的Referer。优点是规则简单，缺点是这些信息都可以伪造，可靠性较低。</p>
<h2 id="IP访问控制"><a href="#IP访问控制" class="headerlink" title="IP访问控制"></a>IP访问控制</h2><p>IP地址在互联网上具有唯一性，我们可以针对异常的请求客户端的IP进行限制，以达到访问控制的目的。<br>    1. 支持对一个或多个IP的访问控制<br>    2. 针对IP段进行限制<br>    3. 对区域进行访问限制</p>
<h2 id="Referer防盗链"><a href="#Referer防盗链" class="headerlink" title="Referer防盗链"></a>Referer防盗链</h2><p>Referer在HTTP协议中有特殊的用途，当浏览器向服务端发送请求时会带Referer头，告知该请求是从哪个链接来的。常用于页面访问统计，图片的防盗链。</p>
<p>流媒体直播同样适用，当发送请求到达CDN服务器后，CDN服务器检查客户URL中是否有符合预先规定的Referer，来决定禁止或允许该请求。</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li>应特别指明空引用的处理方式，即该请求头中没有携带Referer头部，通常是直接在浏览器访问该URL或通过非浏览器的方式访问时，请求头不会带有Referer头部，默认采用禁止空引用的方式，当然可以自定义规则。</li>
<li>Refer很容易伪造，因此Referer防盗链安全性较低</li>
</ol>
<h1 id="高级防盗链"><a href="#高级防盗链" class="headerlink" title="高级防盗链"></a>高级防盗链</h1><p>流媒体直播中，常采用时间戳防盗链、swf防盗链、回源鉴权防盗链等方式。时间戳防盗链的特点是加密的URL具有时效性，无法伪造，当到达过期时间后URL不再被允许访问，适合一些对“时效性”有要求的场景。使用时间戳防盗链需要内容提供商和CDN服务商配合，内容提供商负责生成加密的URL，CDN服务商负责根据预先设定的规则对URL进行合理化验证。时间戳是由于实现原理简单、可靠性高、推荐使用。</p>
<p>swf防盗链为RTMP协议所特有，其特点为客户需要提前将swf文件上传到CDN节点，有客户端和CDN节点在请求过程中基于规定的算法进行加密和解密验证，CDN验证通过则响应该请求，验证失败则拒绝。</p>
<p>回源鉴权的特点是CDN节点每次接收到的请求，都需要先回源进行验证，验证通过才认为请求合法，继续提供服务，适用于对防盗链有很高的实时性要求的场景。另外，一些具有特殊性的防盗链，CDN默认不支持的情况下也可以考虑采用回源鉴权的形式。</p>
<h2 id="时间戳防盗链"><a href="#时间戳防盗链" class="headerlink" title="时间戳防盗链"></a>时间戳防盗链</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ol>
<li>当用户发起请求视频播放时，用户的请求会被引导至客户端源站。例如，终端用户发送的请求URL为：<a href="http://www.example.com/test.flv" target="_blank" rel="noopener">http://www.example.com/test.flv</a></li>
<li>源站通过一系列参数共同加密生成一串密文wsSecret。</li>
<li>终端用户利用源站返回的URL，重新向服务商CDN发起请求。</li>
<li>服务商CDN节点进行验证，请求是否过期以及加密穿是否匹配。</li>
</ol>
<p>目前服务商支持绝对时间和相对时间两种方式的时间戳防盗链控制。</p>
<ul>
<li><p>绝对时间控制方式原理如下：<br>此方式用于生成密文的参数有过期时间wsTime、请求直播流、服务商key、ip地址串。假设过期时间为：4d024e80，用户请求的直播流为：test.flv，服务商key为：abc，ip请求地址为：192.168.2.1，对以上数据进行md5加密，得到一个md5密文，假设该密文为a1b2，则源站返回给用户的URL为：<a href="http://cdn.example.com/test.flv?wsSecret=a1b2&amp;wsTime=4d024e80" target="_blank" rel="noopener">http://cdn.example.com/test.flv?wsSecret=a1b2&amp;wsTime=4d024e80</a><br>终端用户利用该URL重新向服务商节点发起请求。<br>服务商进行验证：</p>
<ol>
<li>根据过期时间wsTime和当前时间进行比较，确认请求是否过期。</li>
<li>根据约定的md5计算方式和密文，计算出md5加密串后和url中原始的加密串进行比较。<br>只有1和2都验证通过，请求才会被认为是合法的。不合法的请求可以采取禁止访问或者302重定向到指定的url。</li>
</ol>
</li>
<li><p>相对时间控制方式原理如下：<br>与绝对时间控制方式相比，相对时间控制方式使用参数keepTime和wsTime来共同决定过期时间，wsTime表示终端用户向源站请求url时，源站的机器时间，keepTime表示url 有效的时间长度，以秒为单位，以十六进制或十进制表示，同时keeptime作为参数加入加密串的计算。<br>例如： rtmp://rtmpup4.pstatp.com/live/xxxxxx/xxxx?wsSecret=xxx&amp;keeptime=7200&amp;wsTime=xxx<br>服务商节点判断该URL请求是否过期，方式如下：</p>
</li>
</ul>
<ul>
<li>若当前时间 - wsTime &lt; keepTime 时，表示URL请求未过期；</li>
<li>若当前时间 - wsTime &gt;= keeptime ，表示URL请求已过期；</li>
<li>若keepTime为空，则按照发布点配置的默认过期时间来进行判断（如5分钟）。同样，相对时间控制方式除校验有效期之外，也需要校验md5加密串是否匹配。</li>
</ul>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ol>
<li>确认时间的表示格式。默认采用的是Unix时间戳的形式，比如1371982466表示时间是2013-06-23 18:14:26，支持其他一些时间表达格式，比如：<ul>
<li>20130623181426</li>
<li>2013-06-23</li>
<li>51c6ca82（推荐此表示方式，将十进制的1371982466采用16进制表示，有较好的隐蔽性）</li>
</ul>
</li>
<li>需要确认使用绝对时间还是相对时间控制方式，使用相对时间控制的话还需要确认是否需要使用keepTime，不使用keepTime需要与客户确认默认配置的过期时长。</li>
<li>确认参与md5计算的相关参数，以及组合顺序。</li>
</ol>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><ol>
<li>时间戳防盗链默认支持，可以直接配置，不需要再次开发</li>
<li>当防盗链涉及的参数发生变更时，需要通知CDN进行配合更改，原则上密文一旦确定尽量不要发生变动，不然可能导致源和加速节点使用的密文不一致，请求全部验证不通过</li>
<li>使用IP进行md5计算可能带来一些问题：如果用户发送请求加密使用的IP1，而到CDN这边用的是另外一个IP2，这样就会被禁止访问。这在从4G切换到Wi-Fi时极易容易发生。</li>
</ol>
<h2 id="回源鉴权防盗链"><a href="#回源鉴权防盗链" class="headerlink" title="回源鉴权防盗链"></a>回源鉴权防盗链</h2><h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><ol>
<li>终端用户向CDN请求视频内容，在请求中携带需要回源鉴权的参数。例如：  <a href="http://www.test.com/live/channel.flv?key1=vaule1&key2=vaule2" target="_blank" rel="noopener">http://www.test.com/live/channel.flv?key1=vaule1&amp;key2=vaule2</a> </li>
<li>CDN节点可通过POST或者GET方式向用户鉴权服务器返回需要鉴权的参数，鉴权参数需要用户提前告知CDN。</li>
<li>鉴权服务器根据CDN传送而来的鉴权信息，进行防盗链判断，决定是否允许用户请求该直播视频，并将结果返回给CDN节点。</li>
<li>CDN节点根据客户鉴权服务器返回的结果，响应或者拒绝终端用户的视频请求。</li>
</ol>
<h3 id="应用场景举例："><a href="#应用场景举例：" class="headerlink" title="应用场景举例："></a>应用场景举例：</h3><ol>
<li>客户技术实力比较强，又不希望第三方公司知悉其防盗链原理时，可使用回源鉴权防盗链。</li>
<li>CDN无法满足客户特殊防盗链需求时，可使用回源鉴权防盗链。</li>
</ol>
<h3 id="使用方法："><a href="#使用方法：" class="headerlink" title="使用方法："></a>使用方法：</h3><ol>
<li>告知CDN，回源鉴权的参数</li>
<li>告知CDN，鉴权服务器地址。</li>
<li>告知CDN，回源鉴权的方式，目前支持get及post两种</li>
<li>告知CDN，鉴权结果，例如1代表成功，0代表失败</li>
<li>告知CDN，超时等待时间，及超时如何处理，例如，鉴权服务器3S不响应，就同意请求，或拒绝请求。</li>
</ol>
<h3 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a>注意事项：</h3><ol>
<li>每次请求都需要先进行鉴权，在请求量较大时，需要考虑鉴权服务器的压力</li>
<li>该鉴权形式客户需要维护专门的鉴权服务器。</li>
</ol>
]]></content>
      <categories>
        <category>工具技巧</category>
      </categories>
      <tags>
        <tag>Tech</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos7禁用密码登录</title>
    <url>/2020/02/18/Centos7-disable-password-login/</url>
    <content><![CDATA[<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ul>
<li>编辑<code>/etc/ssh/sshd_config</code></li>
<li>将<code>PasswordAuthentication</code>参数值修改为no： <code>PasswordAuthentication no</code></li>
<li>重启ssh服务：<code>systemctl restart sshd.service</code></li>
</ul>
]]></content>
      <tags>
        <tag>Tech</tag>
      </tags>
  </entry>
  <entry>
    <title>打造离线下载服务器</title>
    <url>/2020/08/10/CCAA-DownloadServer/</url>
    <content><![CDATA[<h2 id="安装CCAA-CentOS-Caddy-AriaNg-Aria"><a href="#安装CCAA-CentOS-Caddy-AriaNg-Aria" class="headerlink" title="安装CCAA(CentOS + Caddy + AriaNg + Aria)"></a>安装CCAA(CentOS + Caddy + AriaNg + Aria)</h2><p>一键脚本，一路回车就完事</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bash &lt;(curl -Lsk https://raw.githubusercontent.com/helloxz/ccaa/master/ccaa.sh) cdn</span><br></pre></td></tr></table></figure>

<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p><code>ccaa</code>:进⼊CCAA操作界⾯ </p>
<p><code>ccaa status</code>:查看CCAA运⾏状态 </p>
<p><code>ccaa stop</code>:停⽌CCAA </p>
<p><code>ccaa start</code>:启动CCAA</p>
<p><code>ccaa restart</code>:重启CCAA</p>
<p><code>ccaa -v</code>:查看CCAA版本（2.0开始⽀持）</p>
<h2 id="下载页面"><a href="#下载页面" class="headerlink" title="下载页面"></a>下载页面</h2><p><img src="https://pic.oldzhg.com/uPic/D2XLDg.png" alt="aria2NG"></p>
]]></content>
      <categories>
        <category>ECS七天训练营</category>
      </categories>
  </entry>
  <entry>
    <title>Certbot使用教程</title>
    <url>/2019/10/03/Certbot%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="这篇文章主要讲的就是如何让自己的网站免费从HTTP升级为HTTPS，使用的是-Let’s-Encrypt的证书。实际上也就是一个Let’s-Encrypt-免费证书获取教程-。"><a href="#这篇文章主要讲的就是如何让自己的网站免费从HTTP升级为HTTPS，使用的是-Let’s-Encrypt的证书。实际上也就是一个Let’s-Encrypt-免费证书获取教程-。" class="headerlink" title="这篇文章主要讲的就是如何让自己的网站免费从HTTP升级为HTTPS，使用的是 Let’s Encrypt的证书。实际上也就是一个Let’s Encrypt 免费证书获取教程 。"></a>这篇文章主要讲的就是如何让自己的网站免费从HTTP升级为HTTPS，使用的是 <a href="https://letsencrypt.org/" target="_blank" rel="noopener">Let’s Encrypt</a>的证书。实际上也就是一个Let’s Encrypt 免费证书获取教程 。</h3><h2 id="Let’s-Encrypt-简介"><a href="#Let’s-Encrypt-简介" class="headerlink" title="Let’s Encrypt 简介"></a>Let’s Encrypt 简介</h2><p>如果要启用HTTPS，我们就需要从证书授权机构(以下简称CA) 处获取一个证书，Let’s Encrypt 就是一个 CA。我们可以从 Let’s Encrypt 获得网站域名的免费的证书。这篇文章也主要讲的是通过 Let’s Encrypt + Nginx 来让网站升级到HTTPS。</p>
<h2 id="Certbot-简介"><a href="#Certbot-简介" class="headerlink" title="Certbot 简介"></a>Certbot 简介</h2><p><a href="https://certbot.eff.org/" target="_blank" rel="noopener">Certbot</a> 是Let’s Encrypt官方推荐的获取证书的客户端，可以帮我们获取免费的Let’s Encrypt 证书。Certbot 是支持所有 Unix 内核的操作系统的，个人博客的服务器系统是CentOS 7，这篇教程也是通过在个人博客上启用HTTPS的基础上完成的。</p>
<h2 id="获取免费证书"><a href="#获取免费证书" class="headerlink" title="获取免费证书"></a>获取免费证书</h2><ol>
<li><p>安装Certbot客户端</p>
<p><code>yum install certbot</code></p>
</li>
<li><p>获取证书</p>
<p><code>certbot certonly --webroot -w /var/www/example -d [example.com](http://example.com/) -d [www.example.com](http://www.example.com/)</code></p>
<blockquote>
<p>这个命令会为 example.com 和 <a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a> 这两个域名生成一个证书，使用 –webroot 模式会在 /var/www/example 中创建 .well-known 文件夹，这个文件夹里面包含了一些验证文件，certbot 会通过访问 example.com/.well-known/acme-challenge 来验证你的域名是否绑定的这个服务器。这个命令在大多数情况下都可以满足需求，</p>
</blockquote>
</li>
</ol>
<p>但是有些时候我们的一些服务并没有根目录，例如一些微服务，这时候使用 <code>--webroot</code> 就走不通了。certbot 还有另外一种模式 <code>--standalone</code> ， 这种模式不需要指定网站根目录，他会自动启用服务器的443端口，来验证域名的归属。我们有其他服务（例如nginx）占用了443端口，就必须先停止这些服务，在证书生成完毕后，再启用。</p>
<p><code>certbot certonly --standalone -d [example.com](http://example.com/) -d [www.example.com](http://www.example.com/)</code></p>
<p>证书生成完毕后，我们可以在 <code>/etc/letsencrypt/live/</code> 目录下看到对应域名的文件夹，里面存放了指向证书的一些快捷方式。</p>
<p>这时候我们的第一生成证书已经完成了，接下来就是配置我们的web服务器，启用HTTPS。</p>
<p><img src="http://pic.oldzhg.com/uPic/Vbpfn1.png" alt=""></p>
<h2 id="自动更新-SSL-证书"><a href="#自动更新-SSL-证书" class="headerlink" title="自动更新 SSL 证书"></a>自动更新 SSL 证书</h2><p>配置完这些过后，我们的工作还没有完成。 Let’s Encrypt 提供的证书只有90天的有效期，我们必须在证书到期之前，重新获取这些证书，certbot 给我们提供了一个很方便的命令，那就是 <code>certbot renew</code>。 通过这个命令，他会自动检查系统内的证书，并且自动更新这些证书。 我们可以运行这个命令测试一下</p>
<p><code>certbot renew --dry-run</code></p>
<p>我在运行的时候出现了这个错误</p>
<blockquote>
<p>Attempting to renew cert from /etc/letsencrypt/renewal/api.diamondfsd.com.conf produced an unexpected error: At least one of the required ports is already taken.. Skipping.</p>
</blockquote>
<p><img src="http://pic.oldzhg.com/uPic/KEdX6m.png" alt=""></p>
<p>这是因为我的</p>
<p><a href="http://api.diamondfsd.com/" target="_blank" rel="noopener">api.diamondfsd.com</a></p>
<p>生成证书的时候使用的是</p>
<p><code>--standalone</code></p>
<p>模式，验证域名的时候，需要启用443端口，这个错误的意思就是要启用的端口已经被占用了。 这时候我必须把</p>
<p><code>nginx</code></p>
<p>先关掉，才可以成功。果然，我先运行</p>
<p><code>service nginx stop</code></p>
<p>运行这个命令，就没有报错了，所有的证书都刷新成功。</p>
<p>证书是90天才过期，我们只需要在过期之前执行更新操作就可以了。 这件事情就可以直接交给定时任务来完成。linux 系统上有 <code>cron</code> 可以来搞定这件事情。 我新建了一个文件 <code>certbot-auto-renew-cron</code>， 这个是一个 <code>cron</code> 计划，这段内容的意思就是 每隔 两个月的 凌晨 2:15 执行 更新操作。</p>
<p><code>15 2 * */2 * certbot renew --pre-hook &quot;service nginx stop&quot; --post-hook &quot;service nginx start&quot;</code></p>
<p><code>--pre-hook</code> 这个参数表示执行更新操作之前要做的事情，因为我有 <code>--standalone</code> 模式的证书，所以需要 停止 <code>nginx</code> 服务，解除端口占用。 <code>--post-hook</code> 这个参数表示执行更新操作完成后要做的事情，这里就恢复 <code>nginx</code> 服务的启用</p>
<p>最后我们用 <code>crontab</code> 来启动这个定时任务</p>
<p><code>crontab certbot-auto-renew-cron</code></p>
<p>至此，整个网站升级到HTTPS就完成了。 总结一下我们需要做什么</p>
<ol>
<li>获取Let’s Encrypt 免费证书</li>
<li>配置Nginx开启HTTPS</li>
<li>定时刷新证书</li>
</ol>
]]></content>
      <tags>
        <tag>Tech</tag>
      </tags>
  </entry>
  <entry>
    <title>在 macOS 中使用 GPG 密钥提交代码至 Github</title>
    <url>/2020/03/20/Commit-the-code-to-Github-with-the-GPG-key-in-macOS/</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>普通的 HTTPS 和 RSA 密钥方式提交代码，并不能判断是谁提交的代码，多人可以使用同一套验证进行提交，而 GPG 密钥就可以避免此问题，可以对提交者进行验证。</p>
<h2 id="创建密钥"><a href="#创建密钥" class="headerlink" title="创建密钥"></a>创建密钥</h2><h3 id="安装工具"><a href="#安装工具" class="headerlink" title="安装工具"></a>安装工具</h3><p>macOS 上创建密钥需要安装 GPG 命令行工具或者 GUI 工具，下载地址：<a href="https://www.vvave.net/go/aHR0cHM6Ly9ncGd0b29scy5vcmcv" target="_blank" rel="noopener">点击跳转</a>。安装完成后即可使用终端生成 GPG 密钥</p>
<h3 id="生成密钥对"><a href="#生成密钥对" class="headerlink" title="生成密钥对"></a>生成密钥对</h3><p>创建一个 GPG 密钥对，因为 GPG 有多个版本，因此可能需要查阅官方的支持手册来获得适用的命令，GitHub 适用的密钥必须适用 RSA 密钥且具有 4096 位长度。</p>
<ul>
<li>如果使用的是 2.1.17 及以后版本，可以使用下述命令进行生成。</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">$ gpg --full-<span class="keyword">generate</span>-key</span><br></pre></td></tr></table></figure>

<ul>
<li>如果使用的不是 2.1.17 及以后的版本，可使用以下命令。</li>
</ul>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line">$ gpg --<span class="keyword">default</span>-<span class="keyword">new</span>-<span class="built_in">key</span>-algo rsa4096 --gen-<span class="built_in">key</span></span><br></pre></td></tr></table></figure>

<ol>
<li>然后根据屏幕提示确认使用的加密方式，默认为 RSA 。接下来确认密钥对强度，选择为 4096。</li>
<li>输入用户的信息并进行确认。</li>
<li>输入个安全的密码。</li>
</ol>
<h3 id="查看密钥对"><a href="#查看密钥对" class="headerlink" title="查看密钥对"></a>查看密钥对</h3><figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line"><span class="comment">$</span> <span class="comment">gpg</span> --<span class="comment">list</span><span class="literal">-</span><span class="comment">secret</span><span class="literal">-</span><span class="comment">keys</span> --<span class="comment">keyid</span><span class="literal">-</span><span class="comment">format</span> <span class="comment">LONG</span></span><br></pre></td></tr></table></figure>

<p>从列表中即可看到本机存在的全部 GPG 密钥对，假定以 ID 为 3AA5C34371567BD2 的密钥对为例。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ gpg --list-secret-keys --keyid-format LONG</span><br><span class="line">/Users/hubot/.gnupg/secring.gpg</span><br><span class="line">------------------------------------</span><br><span class="line">sec   <span class="number">4096</span>R/<span class="number">3</span>AA5C34371567BD2 <span class="number">2016</span><span class="number">-03</span><span class="number">-10</span> [expires: <span class="number">2017</span><span class="number">-03</span><span class="number">-10</span>]</span><br><span class="line">uid                          Hubot </span><br><span class="line">ssb   <span class="number">4096</span>R/<span class="number">42</span>B317FD4BA89E7A <span class="number">2016</span><span class="number">-03</span><span class="number">-10</span></span><br></pre></td></tr></table></figure>

<p>导出密钥对信息</p>
<figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line"><span class="comment">$</span> <span class="comment">gpg</span> --<span class="comment">armor</span> --<span class="comment">export</span> <span class="comment">3AA5C34371567BD2</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>小贴士：密钥对信息会以 <code>-----BEGIN PGP PUBLIC KEY BLOCK-----</code> 字符串开头，以 <code>-----END PGP PUBLIC KEY BLOCK-----</code> 字符串结束。</p>
</blockquote>
<h2 id="添加密钥"><a href="#添加密钥" class="headerlink" title="添加密钥"></a>添加密钥</h2><p>将复制出来的密钥串粘贴至 GitHub 的密钥页面中，<a href="https://www.vvave.net/go/aHR0cHM6Ly9naXRodWIuY29tL3NldHRpbmdzL2tleXM=" target="_blank" rel="noopener">点击跳转</a>。</p>
<h2 id="提交代码"><a href="#提交代码" class="headerlink" title="提交代码"></a>提交代码</h2><p>查看本地密钥对</p>
<figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line"><span class="comment">$</span> <span class="comment">gpg</span> --<span class="comment">list</span><span class="literal">-</span><span class="comment">secret</span><span class="literal">-</span><span class="comment">keys</span> --<span class="comment">keyid</span><span class="literal">-</span><span class="comment">format</span> <span class="comment">LONG</span></span><br></pre></td></tr></table></figure>

<p>为本地仓库配置 GPG 密钥</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ git<span class="built_in"> config </span>--global user.signingkey 3AA5C34371567BD2</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小贴士：本文以 <code>3AA5C34371567BD2</code> 为例，请输入真实的密钥对 ID。</p>
</blockquote>
<p>为当前的项目配置密钥认证</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ git<span class="built_in"> config </span>commit.gpgsign <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>为全部项目配置密钥认证</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ git<span class="built_in"> config </span>--global commit.gpgsign <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>小贴士：配置后使用提交命令即可在 GitHub 网页中看到 出现 <strong>Verified</strong> 绿色标记。</p>
</blockquote>
<p>–</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://www.vvave.net/go/aHR0cHM6Ly9oZWxwLmdpdGh1Yi5jb20vZW4vYXJ0aWNsZXMvZ2VuZXJhdGluZy1hLW5ldy1ncGcta2V5" target="_blank" rel="noopener">Generating a new GPG key - GitHub Help</a></li>
<li><a href="https://www.vvave.net/go/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTEwNTQzMzMvYXJ0aWNsZS9kZXRhaWxzLzgzOTM0MzA5" target="_blank" rel="noopener">使用 GPG 密钥验证 Github 提交 - CSDN</a></li>
</ul>
]]></content>
      <categories>
        <category>工具技巧</category>
      </categories>
      <tags>
        <tag>Tech</tag>
      </tags>
  </entry>
  <entry>
    <title>Django学习笔记</title>
    <url>/2020/03/23/Django-study-notes/</url>
    <content><![CDATA[<h1 id="django使用https"><a href="#django使用https" class="headerlink" title="django使用https"></a>django使用https</h1><p>使用 runserver 是不能使用 https 的</p>
<p>解决办法:使用 runsslserver</p>
<p>步骤:</p>
<p>1.安装:</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">pip <span class="keyword">install </span>django-<span class="keyword">extensions </span></span><br><span class="line">pip <span class="keyword">install </span>django-werkzeug-debugger-runserver </span><br><span class="line">pip <span class="keyword">install </span>pyOpenSSL</span><br></pre></td></tr></table></figure>

<p>2.启动方式</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">python manage.py runsslserver <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">8100</span> \</span><br><span class="line">--certificate /etc/pki/libvirt-spice/server-cert.pem \</span><br><span class="line">--key /etc/pki/libvirt-spice/server-key.pem </span><br><span class="line">或者</span><br><span class="line">python3 manage.py runsslserver <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">8000</span> --certificate /path/to/certificate.crt --key /path/to/key.key</span><br></pre></td></tr></table></figure>

<p>3.修改setting.py中的INSTALLED_APPS</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS = (...</span><br><span class="line"><span class="string">"sslserver"</span>,</span><br><span class="line">...</span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<p>又拍云默认屏蔽了请求源站后的跟随参数，如果配置了CDN值得注意</p>
<p>Django两种请求方式GET和POST</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">request</span><span class="selector-class">.GET</span><span class="selector-attr">[<span class="string">'username'</span>]</span></span><br><span class="line"><span class="selector-tag">request</span><span class="selector-class">.POST</span><span class="selector-attr">[<span class="string">'username'</span>]</span></span><br></pre></td></tr></table></figure>

<p>值得注意的是<strong>POST可以接受空值，而GET接受空值时会报错</strong>，可以加条件判断跳过</p>
<p>也可以采用下面这种方式</p>
<p>Try this and observe username printed: <code>http://127.0.0.1:8000/StartPage?username=test</code>.</p>
<p>Use <a href="https://docs.python.org/2/library/stdtypes.html#dict.get" target="_blank" rel="noopener"><code>get()</code></a> and avoid <code>MultiValueDictKeyError</code> errors:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">request.GET.get(<span class="string">'username'</span>, <span class="string">''</span>)</span><br></pre></td></tr></table></figure>

<p>后面可以设置成为空的默认参数</p>
<p>还有前后传参的时候不要把变量名写错了，不然会很麻烦。</p>
<p>看这位大佬就排除半天问题，最后仅仅是因为一个变量名的原因。</p>
<blockquote>
<p>此处之所以出错，获取不到，是因为之前同事笔误，把参数名：function_group_id，误写为了fucntion_group_id，改回来，即可正常传递参数了。</p>
<p>​                                                                                                                                            ———<a href="https://www.crifan.com/django_request_query_params_cannot_receive_get_para/" target="_blank" rel="noopener">引用来源</a></p>
</blockquote>
<h1 id="基于Django框架的网站部署"><a href="#基于Django框架的网站部署" class="headerlink" title="基于Django框架的网站部署"></a><a href="https://segmentfault.com/a/1190000008507042" target="_blank" rel="noopener">基于Django框架的网站部署</a></h1><h2 id="1-域名"><a href="#1-域名" class="headerlink" title="1.域名"></a>1.域名</h2><p>    首先，当我们输入一个网址<a href="http://www.example.com/时，首先经过DNS解析到对应的IP地址，从而对该IP实现访问。所以，要让别人访问我们项目的第一步，就是需要拥有两样东西，域名和公网ip。" target="_blank" rel="noopener">http://www.example.com/时，首先经过DNS解析到对应的IP地址，从而对该IP实现访问。所以，要让别人访问我们项目的第一步，就是需要拥有两样东西，域名和公网ip。</a><br>    域名的获得很简单，随便注册购买一个就好了。然后需要的是将域名解析到你的公网ip。而公网ip，一般在购买云服务器的时候能获得。<br>    经过这一步，我们实现了：请求–&gt;DNS–&gt;服务器ip，而我们的最终目的就是：请求–&gt;DNS–&gt;服务器ip–&gt;黑盒子–&gt;项目wsgi应用</p>
<h2 id="2-使用gunicorn运行项目"><a href="#2-使用gunicorn运行项目" class="headerlink" title="2.使用gunicorn运行项目"></a>2.使用gunicorn运行项目</h2><p>具体gunicorn 的使用可以自行google一下</p>
<h2 id="3-nginx接收外部请求，内部转发"><a href="#3-nginx接收外部请求，内部转发" class="headerlink" title="3.nginx接收外部请求，内部转发"></a>3.nginx接收外部请求，内部转发</h2><p>在/etc/nginx/sites-available/文件夹下，新建一个文件blog，并添加如下简单设置</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  你的域名 你的公网ip(可选);</span><br><span class="line">    <span class="attribute">access_log</span>  /var/log/nginx/blog.log;</span><br><span class="line">    <span class="attribute">location</span> /static &#123;</span><br><span class="line">        <span class="comment">#静态文件如js，css的存放目录</span></span><br><span class="line">        <span class="attribute">root</span> /project/blog;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">include</span> proxy_params;</span><br><span class="line">        <span class="comment"># 从外部接收请求后转发到本地的8000端口</span></span><br><span class="line">        <span class="attribute">proxy_pass</span> http://127.0.0.1:8000;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面我们就可以明白，nginx 接收到请求后，转发给gunicorn正在监听的本地8000端口，gunicorn根据请求调用项目中相应的应用函数后返回结果。<br>自此我们就基本实现了请求–&gt;DNS–&gt;服务器ip–&gt;nginx（80端口）–&gt;127.0.0.1：8000–&gt;项目wsgi应用<br>而关于nginx和gunicorn的具体配置还有许多，不妨多google一下延伸学习</p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h2><p>gunicorn让项目跑起来<br>nginx负责接收请求和转发请求到运行中项目监听请求的端口<br>部署到线上，主要需要域名，公网ip，二者均可以通过云服务器来解决，所以最好还是直接买个云服务器实践一下，just do it</p>
<p>Python3 同级目录直接import</p>
<p>不同级目录</p>
<p>from 目录 import 文件</p>
<p>ls | grep -v .mp4 | xargs rm -r</p>
<h2 id="捕获url参数"><a href="#捕获url参数" class="headerlink" title="捕获url参数"></a>捕获url参数</h2><p>进行url匹配时 把需要捕获的部分设置成正则表达式的组<br>Django框架 会自动把组内参数传递给对应视图函数</p>
<h3 id="1-位置参数-要求顺序"><a href="#1-位置参数-要求顺序" class="headerlink" title="1.位置参数 (要求顺序)"></a>1.位置参数 (要求顺序)</h3><p>使用正则位置参数 视图的形参名可以随意指定<br><code>re_path(r&quot;index(\d+)&quot;, views.index)</code><br>(\d+)内的参数将被传递给index视图函数的形参</p>
<p>给位置参数必须数量一致，路由中有几个正则组，视图函数中就应该有几个形参，包含自带request参数</p>
<p>request 包含 用户通过浏览器请求的参数</p>
<h3 id="2-关键字参数-（可以指定顺序）"><a href="#2-关键字参数-（可以指定顺序）" class="headerlink" title="2.关键字参数 （可以指定顺序）"></a>2.关键字参数 （可以指定顺序）</h3><p><code>re_path(r&quot;index(?P&lt;name&gt;\d+)&quot;, views.index)</code><br><code>(?P&lt;name&gt;\d+)</code>内的参数通过关键字参数传递给视图函数<br>视图函数必须以name命名形参，也就是命名必须一致，此时参数顺序不要求</p>
<p><strong>小结：</strong>在url正则表达式通过’()‘来匹配传递的参数，如<code>’(\w+)&#39;</code>代表匹配字符串，然后在视图函数的形参中加入对应数量的参数（必须在视图函数的形参中接收），即可在后台接收到传入的参数，他会根据对应的顺序依次赋值。当然我们也可以在匹配参数过程中指定对应的形参名称，如：</p>
<p><code>url(r&#39;^params_test_reg/str(?P&lt;str&gt;\w+)page(?P&lt;page&gt;\d+)/$&#39;,params_test_reg),</code></p>
<p>**位置参数与关键字参数不能混用，但是用了一个位置参数时，要求剩下的必须都是位置参数，否则出现 <code>missing 1 required positional argument:</code>错误。</p>
<p><code>request</code>是一个<code>HttpRquest</code>类型的对象</p>
<p>request参数是一个WSGIRequest对象<br>WSGIRequest 对象属于django.core.handlers.wsgi.WSGIRequest<br>request对象包含浏览器请求的信息 是将WISG协议中传递给框架的env信息的再次封装</p>
<h4 id="WSGIRequest对象的属性"><a href="#WSGIRequest对象的属性" class="headerlink" title="WSGIRequest对象的属性"></a>WSGIRequest对象的属性</h4><p><strong>request.path</strong>: 返回字符串 表示请求的路径 不包含域名和参数部分<br><strong>request.method</strong>: 返回字符串 表示HTTP请求的方式 如: “GET” “POST”<br><strong>request.encoding</strong>: 返回字符串 表示请求的编码格式 如果为None表示使用浏览器默认设置utf-8 <strong>注意:这个属性不是只读的如果修改 接下来对属性的访问使用新的encoding值</strong></p>
<p>可以在templates下新建404.html 和 500.html<br>将使用此模板替代默认404页面、500页面</p>
<h4 id="QueryDict对象"><a href="#QueryDict对象" class="headerlink" title="QueryDict对象"></a>QueryDict对象</h4><p>WSGIRequest 对象的GET 和POST 属性用来取值<br>request.GET 或 request.POST 是一个 QueryDict 对象<br>QueryDict 对象属于 django.http.request.QueryDict</p>
<h4 id="创建QueryDict对象"><a href="#创建QueryDict对象" class="headerlink" title="创建QueryDict对象"></a>创建QueryDict对象</h4><p>q = QueryDict(“a=1&amp;a=2&amp;b=3”)</p>
<h4 id="对QueryDict对象取值"><a href="#对QueryDict对象取值" class="headerlink" title="对QueryDict对象取值"></a>对QueryDict对象取值</h4><p>q[“a”] 返回一个字符串<br>q.get(“b”) 返回一个字符串<br>q.getlist(“a”) 返回一个列表<br>如果取值不存在的键 使用[]取值会报错KeyError 使用get() 返回None 使用getlist 返回空列表</p>
<h4 id="get-方法设置默认值"><a href="#get-方法设置默认值" class="headerlink" title="get()方法设置默认值"></a>get()方法设置默认值</h4><p>q.get(“d”, “default”) 如果没有d这个Key 会返回字符串default<br>q.getlist(“d”, [1, “2”]) 如果没有d 这个Key 会返回列表[1, “2”]</p>
<h4 id="QueryDict与普通字典的区别"><a href="#QueryDict与普通字典的区别" class="headerlink" title="QueryDict与普通字典的区别"></a>QueryDict与普通字典的区别</h4><p>QueryDict的Key可以对应多个值<br>q = queryDict(“a=1&amp;a=2&amp;a=3”)<br>用[]和get()取值有多个值的QueryDict对象时 只返回最后一个Key的值<br>q[“a”] 返回 3<br>q.get(“a”) 返回 3<br>如果要对QueryDict取值Key对应的所有值 使用getlist()方法<br>q.getlist(“a”) 返回一个列表[“1”, “2”, “3”]</p>
<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>Cookie 在访问网站时服务器生成的储存在浏览器的一段文本信息<br>Django中cookie中的值只以字符串形式储存<br>访问服务器时服务器设置一个cookie key为要保存的id值为要保存的信息<br>将cookie发送给浏览器浏览器保存在本地<br>访问服务器时浏览器发送cookie 服务器通过cookie的id取出信息用来判断状态</p>
<h4 id="Cookie的特点"><a href="#Cookie的特点" class="headerlink" title="Cookie的特点"></a>Cookie的特点</h4><p>request.COOKIES是一个普通的Python字典<br>1.以键值对的方式存储 并且只储存字符串类型的值<br>2.通过浏览器访问网站时 浏览器会将所有跟这个网站相关的Cookie发送给网站<br>3.基于域名安全(不会将其他网站的cookie发给不相关的网站)<br>4.有过期时间 如果不指定时间 默认关闭浏览器后cookie就会过期设置cookie</p>
<p>通过HttpResponse类的对象或者它的子类的对象<br>使用对象.set_cookie()设置cookie<br>对象.set_cookie(“key”, value, max_age)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">response = HttpResponse(<span class="string">"设置cookie"</span>)</span><br><span class="line">response.set_cookie(<span class="string">"num"</span>, 1)</span><br><span class="line">renturn response</span><br></pre></td></tr></table></figure>

<p>实际是服务器在ResponseHeader里设置了Set-Cookie的值<br>浏览器发现Set-Cookie的值后会在本地存储对应的cookie</p>
<h4 id="读取cookie"><a href="#读取cookie" class="headerlink" title="读取cookie"></a>读取cookie</h4><p>通过HttpRequest类的对象或者它的子类的对象<br>使用对象.COOKIES[]读取cookie<br>对象.COOKIES[“key”]</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">cookie = request.Cookie[<span class="string">"num"</span>]</span><br><span class="line"><span class="keyword">return</span> HttpResponse(cookie)</span><br></pre></td></tr></table></figure>

<p>在读取cookie时 实际是浏览器在RequsetHeader里设置了Cookie的值<br>浏览器将本地保存的有关这个网站的cookie保存在Cookie全部发送给服务器</p>
<h4 id="Cookie的寿命"><a href="#Cookie的寿命" class="headerlink" title="Cookie的寿命"></a>Cookie的寿命</h4><p>浏览器在保存cookie时默认当浏览器关闭时使cookie过期<br>response.set_cookie(max_age= , expirse= )<br>max_age= 以秒为单位设置cookie过期时间<br>expirse= 以到期日期计算cookie过期时间</p>
<h2 id="session"><a href="#session" class="headerlink" title="session"></a>session</h2><p>Django的session中可以储存任意类型的数据<br>所有的session信息储存在服务器数据库中的session表中<br>表的主键叫做session_key唯一标示session在表中的位置<br>表的值叫做 session_data储存了设置的session键值对<br>过期时间叫做expire_date储存了session过期日期<br>访问服务器时服务器设置session为数据表创建记录<br>服务器发送一个key为sessionid，值为session_key的cookie给浏览器<br>访问时服务器通过key为sessionid的cookie获得session_key<br>后台再通过session_key在数据库中获得session_data</p>
<h4 id="session特点"><a href="#session特点" class="headerlink" title="session特点"></a>session特点</h4><p>1.以键值对的方式存储 并且可以储存<strong>任意类型</strong>的值<br>2.依赖于cookie 唯一标识码sessionid就是cookie的key session_key就是cookie的值<br>3.有过期时间 如果不指定 默认两周时间</p>
<h4 id="设置session"><a href="#设置session" class="headerlink" title="设置session"></a>设置session</h4><p>通过HttpRequest对象的session属性设置和读取session信息<br>保存时类似于给字典添加键值对<br>对象.session[“key”] = value</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">request.session[<span class="string">"username"</span>] = <span class="string">"smart"</span></span><br></pre></td></tr></table></figure>

<h4 id="读取session"><a href="#读取session" class="headerlink" title="读取session"></a>读取session</h4><p>通过HttpRequset对象的session属性读取session信息<br>取值和没有值时的默认值<br>username = 对象.session[“username”]<br>username = 对象.session.get(“key”, 默认值)</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">username = request.session[<span class="string">"username"</span>]</span><br><span class="line">username = request.session.<span class="keyword">get</span>(<span class="string">"username"</span>, <span class="string">"没有数据"</span>)</span><br></pre></td></tr></table></figure>

<h4 id="session的方法"><a href="#session的方法" class="headerlink" title="session的方法"></a>session的方法</h4><p>session_data在数据表中的状态</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">4b662403cdb5656fdba155811da63a59046fe33a:&#123;<span class="string">"username"</span>:<span class="string">"smart"</span>,<span class="string">"password"</span>:<span class="string">"passwd"</span>&#125;</span><br></pre></td></tr></table></figure>

<p>删除session值的部分 也就是session_data中括号中的部分<br>对象.session.clear()<br>删除session整条数据 也就是session_data对应的整条数据表记录<br>对象.session.flush()<br>删除session中指定的键值对<br>del 对象.session[“key”]<br>判断session中是否有对应的key<br>对象.session.has_key(“key”)<br>设置会话的超时时间<br>如果不设置值则等同于设置为None<br>对象.session.set_expory(value)</p>
<ul>
<li>如果value是一个整数，sessionid的cookie将在value秒后过 session也会在value秒后过期</li>
<li>如果value为0，sessionid的cookie浏览器关闭时过期 session会在两周后过期</li>
<li>如果value为None，sessionid的cookie两周后过期 session也会在两周后过期</li>
</ul>
<h2 id="cookie和session的应用场景"><a href="#cookie和session的应用场景" class="headerlink" title="cookie和session的应用场景"></a>cookie和session的应用场景</h2><p>cookie: 记住用户名 安全性要求不高<br>session: 银行卡账户 密码 涉及到安全性比较高的数据</p>
<p><strong>注意：</strong>要使用session还需要密匙种子SECRET_KEY，在app初始化添加进去既可以(app.config[SECRT_KEY] = ‘123WER1245erwrwe&amp;<em>%W34@##</em>&amp;@!)</p>
<h3 id="日志记录"><a href="#日志记录" class="headerlink" title="日志记录"></a>日志记录</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">logger = logging.getLogger(<span class="string">'django'</span>)</span><br><span class="line">logger = logging.getLogger(<span class="string">"console"</span>)</span><br><span class="line">logger.debug(<span class="string">"hello"</span>)</span><br><span class="line">logger.info(<span class="string">'This is an error msg'</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>工具技巧</category>
      </categories>
      <tags>
        <tag>Tech</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 在Mac上安装SQL Server 2017</title>
    <url>/2019/06/13/Docker%20%E5%9C%A8Mac%E4%B8%8A%E5%AE%89%E8%A3%85SQL%20Server%202017/</url>
    <content><![CDATA[<p> 一、镜像安装</p>
<p>1、从Docker库中拉取镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker pull microsoft/mssql-server-linux:2017-latest1</span><br></pre></td></tr></table></figure>

<p>2、拉取完之后，运行该镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker run -e <span class="string">'ACCEPT_EULA=Y'</span> -e <span class="string">'MSSQL_SA_PASSWORD=1234qwer!'</span> \</span><br><span class="line">   -p 1401:1433 --name sql1 \</span><br><span class="line">   -d microsoft/mssql-server-linux:2017-latest123</span><br></pre></td></tr></table></figure>

<p>可以运行多个镜像，保证端口好不一样，name不一样<br><code>-p 1402:1434 --name sql2</code></p>
<p><img src="//pic.oldzhg.com/uPic/S9duGP.jpg" alt="这里写图片描述"></p>
<p>3、要查看您的Docker容器，请使用该docker ps命令。</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">sudo</span> docker ps -<span class="built_in">a1</span></span><br></pre></td></tr></table></figure>

<p>4、更改SA密码</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">sudo docker exec -<span class="literal">it</span> sql1 /opt/mssql-tools/bin/sqlcmd <span class="string">\</span></span><br><span class="line">   -S localhost -U SA -P <span class="string">'1234qwer!'</span> <span class="string">\</span></span><br><span class="line">   -Q <span class="string">'ALTER LOGIN sa WITH PASSWORD="1234qwer!"'</span><span class="number">123</span></span><br></pre></td></tr></table></figure>

<p>5、连接到SQL Server</p>
<ol>
<li>使用该docker exec -it命令在正在运行的容器中启动交互式bash shell。在以下示例sql1中–name，创建容器时由参数指定的名称。</li>
</ol>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">sudo docker exec -<span class="keyword">it</span> sql1 <span class="string">"bash"</span><span class="number">1</span></span><br></pre></td></tr></table></figure>

<ol>
<li>一旦进入容器，用sqlcmd本地连接。Sqlcmd默认不在路径中，因此您必须指定完整路径。</li>
</ol>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/opt/m</span>ssql-tools<span class="regexp">/bin/</span>sqlcmd -S localhost -U SA -P <span class="string">'1234qwer!'</span><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>如果成功，您应该到达sqlcmd命令提示符：1&gt;。</p>
<p>6、使用外部数据库连接工具来连接数据库<br><img src="//pic.oldzhg.com/uPic/JZn2ww.jpg" alt="这里写图片描述"></p>
<p>IP地址是电脑主机的地址，后面要跟<code>,1401</code></p>
<h3 id="二、还原数据库"><a href="#二、还原数据库" class="headerlink" title="二、还原数据库"></a>二、还原数据库</h3><p>1、创建镜像sql1的文件目录</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">sudo</span> docker exec -<span class="keyword">it </span>sql1 mkdir /var/<span class="meta">opt</span>/mssql/<span class="keyword">backup1</span></span><br></pre></td></tr></table></figure>

<p>2、拷贝文件</p>
<blockquote>
<p>可以将bak文件放到用户主目录下面</p>
</blockquote>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">sudo</span> docker <span class="meta">cp</span> CZSBGL3.<span class="keyword">bak </span>sql1:/var/<span class="meta">opt</span>/mssql/<span class="keyword">backup1</span></span><br></pre></td></tr></table></figure>

<p>3、还原数据库</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span> 还原bak文件</span><br><span class="line">sudo docker exec -it sql1 <span class="regexp">/opt/m</span>ssql-tools<span class="regexp">/bin/</span>sqlcmd -S localhost \</span><br><span class="line">   -U SA -P <span class="string">'1234qwer!'</span> \</span><br><span class="line">   -Q <span class="string">'RESTORE FILELISTONLY FROM DISK = "/var/opt/mssql/backup/CZSBGL3.bak"'</span> \</span><br><span class="line">   | tr -s <span class="string">' '</span> | cut -d <span class="string">' '</span> -f <span class="number">1</span>-<span class="number">212345</span></span><br></pre></td></tr></table></figure>

<p>你应看到类似于下面的输出：<br><img src="//pic.oldzhg.com/uPic/i7WRk0.png" alt="这里写图片描述"></p>
<p>4、调用RESTORE DATABASE命令才能还原在容器内的数据库。 为每个文件上一步中指定新路径。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sudo docker exec -it sql1 /opt/mssql-tools/bin/sqlcmd \</span><br><span class="line">   -S localhost -U SA -P '1234qwer!' \</span><br><span class="line">   -Q '<span class="keyword">RESTORE</span> <span class="keyword">DATABASE</span> CZSBGL3 <span class="keyword">FROM</span> DISK = <span class="string">"/var/opt/mssql/backup/CZSBGL3.bak"</span> <span class="keyword">WITH</span> <span class="keyword">MOVE</span> <span class="string">"CZSBGL_NEW"</span> <span class="keyword">TO</span> <span class="string">"/var/opt/mssql/data/CZSBGL3.mdf"</span>, <span class="keyword">MOVE</span> <span class="string">"CZSBGL_NEW_log"</span> <span class="keyword">TO</span> <span class="string">"/var/opt/mssql/data/CZSBGL3.ldf"</span><span class="string">'123</span></span><br></pre></td></tr></table></figure>

<p>你应看到类似于下面的输出：<br><img src="//pic.oldzhg.com/uPic/6ygzws.png" alt="这里写图片描述"></p>
<p>再次连接数据库，你应该能看到数据库列表。</p>
]]></content>
      <tags>
        <tag>Tech</tag>
      </tags>
  </entry>
  <entry>
    <title>如何在Mac上禁止ip</title>
    <url>/2020/03/20/How-to-forbid-an-ip-on-Mac/</url>
    <content><![CDATA[<p> 最近需要在Mac上禁止几个IP的通过，在网上搜到大部分都是通过编辑hosts文件禁用域名的访问。</p>
<p>经过一发查找后发现可以通过Mac上的pf服务达到禁用的目的。</p>
<p>具体pf的命令通过手册查看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">man pfctl</span><br></pre></td></tr></table></figure>

<p>首先用root 权限修改 <code>/etc/sysctl.conf</code> 文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/pf.conf</span><br></pre></td></tr></table></figure>

<p>不用看里面的内容，在最下面添加以下文本，记得替换成你想屏蔽的ip：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 屏蔽ip</span></span><br><span class="line">block drop from any to 17.253.114.253</span><br><span class="line">block drop from any to 131.6.76.53</span><br></pre></td></tr></table></figure>

<p>使用-f命令为pf服务启动指定的conf文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pfctl -f file</span><br><span class="line"><span class="comment">#Load the rules contained in file.  This file may contain macros, tables, options, and normalization, queueing, translation, and filtering rules.</span></span><br></pre></td></tr></table></figure>

<p>使用 <code>-e</code> 命令启用 pf 服务。使用 <code>-E</code> 命令强制重启 pf 服务，使用 <code>-d</code> 命令关闭 pf。</p>
<p>现在我们启动pf服务</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">sudo pfctl -ef <span class="regexp">/etc/</span>pf.conf</span><br></pre></td></tr></table></figure>

<p>此时发现再去ping这几个ip已经ping不通了</p>
<p><img src="//pic.oldzhg.com/uPic/syEbA6.png" alt=""></p>
<p>从 Mavericks 起 pf 服务不再默认开机自启。</p>
<p>如果我们想实现开机自动启动该服务，首先需要关闭系统的SIP，网上有很多方法，这里不再赘述。</p>
<p>然后修改 <code>/System/Library/LaunchDaemons/com.apple.pfctl.plist</code> </p>
<p>当尝试编辑该文件时发现系统是不可读状态，原因是从macOS 10.15开始系统将默认被挂载为只读。</p>
<p><img src="//pic.oldzhg.com/uPic/4GbGTH.png" alt=""></p>
<p>文件详细里面多了一条restricted，被限制写的操作。</p>
<p>还好还有另外的方法，以读写模式重新挂载系统即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mount -uw /  </span><br><span class="line">killall Finder</span><br></pre></td></tr></table></figure>

<p>随后重新打开向 plist 文件中添加 <code>-e</code> 行，如下所示：</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="params">&lt;string&gt;</span>pfctl<span class="params">&lt;/string&gt;</span></span><br><span class="line"><span class="params">&lt;string&gt;</span>-e<span class="params">&lt;/string&gt;</span></span><br><span class="line"><span class="params">&lt;string&gt;</span>-f<span class="params">&lt;/string&gt;</span></span><br><span class="line"><span class="params">&lt;string&gt;</span><span class="meta-keyword">/etc/</span>pf.conf<span class="params">&lt;/string&gt;</span></span><br></pre></td></tr></table></figure>

<p>下次系统启动时可以自动启动pf服务。</p>
]]></content>
      <categories>
        <category>工具技巧</category>
      </categories>
      <tags>
        <tag>Tech</tag>
      </tags>
  </entry>
  <entry>
    <title>SSH隧道技术简介端口转发&amp;SOCKS代理</title>
    <url>/2020/03/28/Introduction-of-SSH-tunneling-technology/</url>
    <content><![CDATA[<h1 id="1、本文的受众"><a href="#1、本文的受众" class="headerlink" title="1、本文的受众"></a>1、本文的受众</h1><p>如果你遇到了以下问题，那么你应该阅读这篇文章</p>
<ol>
<li><p>我听说过这种技术，我对它很感兴趣</p>
</li>
<li><p>我想在家里访问我在公司的机器（写程序，查数据，下电影）。</p>
</li>
<li><p>公司为了防止我们用XX软件封锁了它的端口或者服务器地址。</p>
</li>
<li><p>公司不让我们上XX网站，限制了网址甚至IP。</p>
</li>
<li><p>公司不让我们看关于XX的信息，甚至花血本买了XX设备，能够对内容进行过滤。一看XX内容，链接就中断了。</p>
</li>
<li><p>我爸是搞电脑的，他在家里的路由器上动了手脚，我不能看XXX了。</p>
</li>
</ol>
<p>带着这些问题，我们先从什么是ssh隧道开始。</p>
<h1 id="2、什么是SSH隧道"><a href="#2、什么是SSH隧道" class="headerlink" title="2、什么是SSH隧道"></a>2、什么是SSH隧道</h1><p>首先看下面这张图，我们所面临的大部分情况都和它类似。我们的电脑在右上角，通过公司带有防火墙功能的路由器接入互联网（当然可能还有交换机什么的在中间连接着你和路由器，但是在我们的问题中交换机并不起到什么关键性的作用）。右下脚的部分是一个网站的服务器，它是我们公司防火墙策略的一部分，也就是说公司不希望我们访问这个服务器。在右上角还有一台机器，它也是属于我们的。但是这台机器并不在我们公司里面，换句话说他不受到公司防火墙的限制。最后也是最重要的一点是，我们能够在公司通过互联网直接访问这台机器。或者说这台位于公司防火墙外面的机器需要拥有一个独立的互联网IP，同时公司的防火墙规则不会屏蔽这台机器，并且这台机器运行着一个OpenSSH服务器。</p>
<p><img src="//pic.oldzhg.com/uPic/BGUrhZ.jpg" alt=""></p>
<p>现在，我们清楚地知道了自己所处的网络环境。并且不难理解我们在公司无法访问那个服务器的原因是：线路A-B-C上A-B之间的防火墙屏蔽了对那个服务器的访问。与此同时，我们也很快注意到，线路A-B-D之间、D-C之间是不受阻碍的。相信你已经想到了，在A-B之间的防火墙不会屏蔽对机器d的访问。因此我们可以通过机器d建立一个通道A-B-D-C，从而访问到机器c上的数据。</p>
<p>这条通道可以用很多技术来建立，这里我们仅仅介绍如何使用SSH服务器来建立这样一个通道－他被称为SSH隧道。</p>
<h1 id="3、如何建立本地SSH隧道"><a href="#3、如何建立本地SSH隧道" class="headerlink" title="3、如何建立本地SSH隧道"></a>3、如何建立本地SSH隧道</h1><p>在我们计划建立一个本地SSH隧道之前，我们必须清楚下面这些数据：</p>
<ol>
<li><p>中间服务器d的IP地址</p>
</li>
<li><p>要访问服务器c的IP地址</p>
</li>
<li><p>要访问服务器c的端口</p>
</li>
</ol>
<p>现在，我们把上面这张图变得具体一些，给这些机器加上IP地址。并且根据下面这张图列出我们的计划：</p>
<p><img src="//pic.oldzhg.com/uPic/d9L5Fz.jpg" alt=""></p>
<ol>
<li><p>需要访问234.234.234.234的FTP服务，也就是端口21</p>
</li>
<li><p>中间服务器是123.123.123.123</p>
</li>
</ol>
<p>现在我们使用下面这条命令来达成我们的目的</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">ssh -N -f -L <span class="number">2121</span>:<span class="number">234.234</span><span class="number">.234</span><span class="number">.234</span>:<span class="number">21</span> <span class="number">123.123</span><span class="number">.123</span><span class="number">.123</span></span><br><span class="line">ftp localhost:<span class="number">2121</span> # 现在访问本地<span class="number">2121</span>端口，就能连接<span class="number">234.234</span><span class="number">.234</span><span class="number">.234</span>的<span class="number">21</span>端口了</span><br></pre></td></tr></table></figure>

<p>这里我们用到了SSH客户端的三个参数，下面我们一一做出解释：</p>
<ul>
<li><p>-N 告诉SSH客户端，这个连接不需要执行任何命令。仅仅做端口转发</p>
</li>
<li><p>-f 告诉SSH客户端在后台运行</p>
</li>
<li><p>-L 做本地映射端口，被冒号分割的三个部分含义分别是</p>
<ul>
<li><p>需要使用的本地端口号</p>
</li>
<li><p>需要访问的目标机器IP地址（IP: 234.234.234.234）</p>
</li>
<li><p>需要访问的目标机器端口（端口: 21)</p>
</li>
</ul>
</li>
<li><p>最后一个参数是我们用来建立隧道的中间机器的IP地址(IP: 123.123.123.123)</p>
</li>
</ul>
<p>我们再重复一下-L参数的行为。-L X:Y:Z的含义是，将IP为Y的机器的Z端口通过中间服务器映射到本地机器的X端口。</p>
<p>在这条命令成功执行之后，我们已经具有绕过公司防火墙的能力，并且成功访问到了我们喜欢的一个FTP服务器了。</p>
<h1 id="4、如何建立远程SSH隧道"><a href="#4、如何建立远程SSH隧道" class="headerlink" title="4、如何建立远程SSH隧道"></a>4、如何建立远程SSH隧道</h1><p>通过建立本地SSH隧道，我们成功地绕过防火墙开始下载FTP上的资源了。那么当我们在家里的时候想要察看下载进度怎么办呢？大多数公司的网络是通过路由器接入互联网的，公司内部的机器不会直接与互联网连接，也就是不能通过互联网直接访问。通过线路D-B-A访问公司里的机器a便是不可能的。也许你已经注意到了，虽然D-B-A这个方向的连接不通，但是A-B-D这个方向的连接是没有问题的。那么，我们能否利用一条已经连接好的A-B-D方向的连接来完成D-B-A方向的访问呢？答案是肯定的，这就是远程SSH隧道的用途。</p>
<p>与本地SSH一样，我们在建立远程SSH隧道之前要清楚下面几个参数：</p>
<ul>
<li><p>需要访问内部机器的远程机器的IP地址（这里是123.123.123.123）</p>
</li>
<li><p>需要让远程机器能访问的内部机器的IP地址(这里因为是想把本机映射出去，因此IP是127.0.0.1)</p>
</li>
<li><p>需要让远程机器能访问的内部机器的端口号(端口:22)</p>
</li>
</ul>
<p>在清楚了上面的参数后，我们使用下面的命令来建立一个远程SSH隧道</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">ssh -N -f -R <span class="number">2222</span>:<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">22</span> <span class="number">123.123</span><span class="number">.123</span><span class="number">.123</span></span><br></pre></td></tr></table></figure>

<p>现在，在IP是123.123.123.123的机器上我们用下面的命令就可以登陆公司的IP是192.168.0.100的机器了。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">ssh -p <span class="number">2222</span> localhost</span><br></pre></td></tr></table></figure>

<p>-N，-f 这两个参数我们已经在本地SSH隧道中介绍过了。我们现在重点说说参数-R。该参数的三个部分的含义分别是:</p>
<ul>
<li><p>远程机器使用的端口（2222）</p>
</li>
<li><p>需要映射的内部机器的IP地址(127.0.0.1)</p>
</li>
<li><p>需要映射的内部机器的端口(22)</p>
</li>
</ul>
<p>例如：-R X:Y:Z 就是把我们内部的Y机器的Z端口映射到远程机器的X端口上。</p>
<h1 id="5、建立SSH隧道的几个技巧"><a href="#5、建立SSH隧道的几个技巧" class="headerlink" title="5、建立SSH隧道的几个技巧"></a>5、建立SSH隧道的几个技巧</h1><h2 id="5-1-自动重连"><a href="#5-1-自动重连" class="headerlink" title="5.1 自动重连"></a><strong>5.1 自动重连</strong></h2><p>隧道可能因为某些原因断开，例如：机器重启，长时间没有数据通信而被路由器切断等等。因此我们可以用程序控制隧道的重新连接，例如一个简单的循环或者使用 <a href="http://cr.yp.to/daemontools.html" target="_blank" rel="noopener">djb’s daemontools</a> . 不管用哪种方法，重连时都应避免因输入密码而卡死程序。关于如何安全的避免输入密码的方法，请参考我的 <a href="http://blog.jianingy.com/node/73" target="_blank" rel="noopener">如何实现安全的免密码ssh登录</a> 。这里请注意，如果通过其他程序控制隧道连接，应当避免将SSH客户端放到后台执行，也就是去掉-f参数。</p>
<h2 id="5-2-保持长时间连接"><a href="#5-2-保持长时间连接" class="headerlink" title="5.2 保持长时间连接"></a><strong>5.2 保持长时间连接</strong></h2><p>有些路由器会把长时间没有通信的连接断开。SSH客户端的TCPKeepAlive选项可以避免这个问题的发生，默认情况下它是被开启的。如果它被关闭了，可以在ssh的命令上加上-o TCPKeepAlive=yes来开启。</p>
<p>另一种方法是，去掉-N参数，加入一个定期能产生输出的命令。例如: top或者vmstat。下面给出一个这种方法的例子：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">ssh -R <span class="number">2222</span>:localhost:<span class="number">22</span> <span class="number">123.123</span><span class="number">.123</span><span class="number">.123</span> <span class="string">"vmstat 30"</span></span><br></pre></td></tr></table></figure>

<h2 id="5-3-检查隧道状态"><a href="#5-3-检查隧道状态" class="headerlink" title="5.3 检查隧道状态"></a><strong>5.3 检查隧道状态</strong></h2><p>有些时候隧道会因为一些原因通信不畅而卡死，例如：由于传输数据量太大，被路由器带入stalled状态。这种时候，往往SSH客户端并不退出，而是卡死在那里。一种应对方法是，使用SSH客户端的ServerAliveInterval和ServerAliveCountMax选项。ServerAliveInterval会在隧道无通信后的一段设置好的时间后发送一个请求给服务器要求服务器响应。如果服务器在ServerAliveCountMax次请求后都没能响应，那么SSH客户端就自动断开连接并退出，将控制权交给你的监控程序。这两个选项的设置方法分别是在ssh时加入-o ServerAliveInterval=n和-o ServerAliveCountMax=m。其中n, m可以自行定义。</p>
<h2 id="5-4-如何将端口绑定到外部地址上"><a href="#5-4-如何将端口绑定到外部地址上" class="headerlink" title="5.4 如何将端口绑定到外部地址上"></a><strong>5.4 如何将端口绑定到外部地址上</strong></h2><p>使用上面的方法，映射的端口只能绑定在127.0.0.1这个接口上。也就是说，只能被本机自己访问到。如何才能让其他机器访问这个端口呢？我们可以把这个映射的端口绑定在0.0.0.0的接口上，方法是加上参数-b 0.0.0.0。同时还需要打开SSH服务器端的一个选项－GatewayPorts。默认情况下它应当是被打开的。如果被关闭的话，可以在/etc/sshd_config中修改GatewayPorts no为GatewayPorts yes来打开它。</p>
<h2 id="5-5-如何寻找中间服务器"><a href="#5-5-如何寻找中间服务器" class="headerlink" title="5.5 如何寻找中间服务器"></a><strong>5.5 如何寻找中间服务器</strong></h2><p>如果你家里使用ADSL上网，多半你会比较幸运。一般的ADSL（例如 <a href="http://www.chinaunicom.com/" target="_blank" rel="noopener">联通</a> 的ADSL）都是有互联网地址的。你只需要在家里的路由器上一台装有OpenSSH server机器的SSH端口映射出去即可。同时一些提供SSH访问的虚拟主机也可以用于这一用途。例如： <a href="http://www.hostmonster.com/" target="_blank" rel="noopener">Hostmonser</a> 或者 <a href="http://www.dreamhost.com/" target="_blank" rel="noopener">Dreamhost</a> .</p>
<h2 id="5-6-通过SSH隧道建立SOCKS服务器"><a href="#5-6-通过SSH隧道建立SOCKS服务器" class="headerlink" title="5.6 通过SSH隧道建立SOCKS服务器"></a>5.6 通过SSH隧道建立SOCKS服务器</h2><p>如果我们需要借助一台中间服务器访问很多资源，一个个映射显然不是高明的办法（事实上，高明确实没有用这个方法）。幸好，SSH客户端为我们提供了通过SSH隧道建立SOCKS服务器的功能。</p>
<p>通过下面的命令我们可以建立一个通过123.123.123.123的SOCKS服务器。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">ssh -N -f -D <span class="number">1080</span> <span class="number">123.123</span><span class="number">.123</span> # 将端口绑定在<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>上</span><br></pre></td></tr></table></figure>

<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">ssh -N -f -D <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">1080</span> <span class="number">123.123</span><span class="number">.123</span><span class="number">.123</span> # 将端口绑定在<span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>上</span><br></pre></td></tr></table></figure>

<p>通过SSH建立的SOCKS服务器使用的是SOCKS5协议，在为应用程序设置SOCKS代理的时候要特别注意。</p>
<h1 id="6、总结"><a href="#6、总结" class="headerlink" title="6、总结"></a>6、总结</h1><p>至此，我们已经对如何利用SSH隧道有一个基本的认识了。现在，文章开始时的那些问题应该迎刃而解了吧。这里要特别说一下，由于SSH隧道也使用了SSH加密协议，因此是不会被防火墙上的内容过滤器监控到的。也就是说一切在隧道中传输的数据都是被加密的。当然，离开隧道后的数据还是会保持自己原有的样子，没有加密的数据还是会被后续的路由设备监控到。</p>
<h1 id="7、更多阅读"><a href="#7、更多阅读" class="headerlink" title="7、更多阅读"></a>7、更多阅读</h1><p>实战 SSH 端口转发</p>
<p><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-sshforward/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/l-cn-sshforward/</a></p>
<p>‍从外网 SSH 进局域网，反向代理+正向代理解决方案‍</p>
<p><a href="http://segmentfault.com/a/1190000002718360" target="_blank" rel="noopener">http://segmentfault.com/a/1190000002718360</a></p>
<h1 id="8、参考文献"><a href="#8、参考文献" class="headerlink" title="8、参考文献"></a>8、参考文献</h1><p><a href="http://www.openssh.com/" target="_blank" rel="noopener">OpenSSH网站</a></p>
]]></content>
      <categories>
        <category>工具技巧</category>
      </categories>
      <tags>
        <tag>Tech</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建Java Web开发环境</title>
    <url>/2020/08/11/JavaWeb-Environment/</url>
    <content><![CDATA[<hr>
<h2 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h2><p>这里安装JDK1.8</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">yum -y install java<span class="number">-1.8</span><span class="number">.0</span>-openjdk*</span><br></pre></td></tr></table></figure>

<h2 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h2><ol>
<li><p>下载并安装MySQL</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">wget http://dev.mysql.com/get/mysql57-community-<span class="keyword">release</span>-el7<span class="number">-10.</span>noarch.rpm</span><br><span class="line">yum -y <span class="keyword">install</span> mysql57-community-<span class="keyword">release</span>-el7<span class="number">-10.</span>noarch.rpm</span><br><span class="line">yum -y <span class="keyword">install</span> mysql-community-<span class="keyword">server</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>启动MySQL</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">systemctl <span class="literal">start</span> mysqld.service</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h2 id="安装Tomcat"><a href="#安装Tomcat" class="headerlink" title="安装Tomcat"></a>安装Tomcat</h2><h3 id="Tomcat是什么？"><a href="#Tomcat是什么？" class="headerlink" title="Tomcat是什么？"></a>Tomcat是什么？</h3><p>Tomcat是一个应用服务器。他的作用就是让你写好的Java网站在服务器上运行。</p>
<h3 id="Tomcat安装步骤"><a href="#Tomcat安装步骤" class="headerlink" title="Tomcat安装步骤"></a>Tomcat安装步骤</h3><ol>
<li><p>下载并解压Tomcat压缩包</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">wget https:<span class="regexp">//mi</span>rror.bit.edu.cn<span class="regexp">/apache/</span>tomcat<span class="regexp">/tomcat-8/</span>v8.<span class="number">5.57</span><span class="regexp">/bin/</span>apache-tomcat-<span class="number">8.5</span>.<span class="number">57</span>.tar.gz</span><br><span class="line">tar -zxvf apache-tomcat-<span class="number">8.5</span>.<span class="number">57</span>.tar.gz</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改Tomcat名字</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">mv apache-tomcat<span class="number">-8.5</span><span class="number">.57</span> /usr/local/Tomcat8<span class="number">.5</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>为Tomcat授权</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">chmod +x <span class="regexp">/usr/</span>local<span class="regexp">/Tomcat8.5/</span>bin<span class="regexp">/*.sh</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改Tomcat默认端口号（默认为8080）</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">sed -i <span class="symbol">'s</span>/Connector <span class="keyword">port</span>=<span class="string">"8080"</span>/Connector <span class="keyword">port</span>=<span class="string">"80"</span>/' /usr/local/Tomcat8.<span class="number">5</span>/conf/server.xml</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动Tomcat</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/usr/</span>local<span class="regexp">/Tomcat8.5/</span>bin<span class="regexp">/./</span>startup.sh</span><br></pre></td></tr></table></figure>
</li>
<li><p>访问Tomcat</p>
<p>访问服务器公网地址</p>
</li>
</ol>
]]></content>
      <categories>
        <category>ECS七天训练营</category>
      </categories>
  </entry>
  <entry>
    <title>更改文件 md5</title>
    <url>/2020/03/19/Linux-change-file-md5/</url>
    <content><![CDATA[<p>大家都知道，在我们上传文件到百度云时，他会先读取文件的md5值。</p>
<p>如果该md5在他的数据库中，</p>
<p>就会直接把文件的一个软链接复制到你的云盘中，给你一种光速上传的感觉。</p>
<p>但是所有资源都要经过百度云的审查之后才能上传成功，否则就会有各种原因无法访问。</p>
<p>所以重要文件不建议放在百度云，说不定哪天你就拿不回来了。</p>
<p>回到正题，现在我想上传一个video到百度云上，发现之前有人上传过导致被和谐。</p>
<p>我们可以通过修改md5的值实现让百度以为这是另一个文件。</p>
<p>最安全的方法是压缩后再上传，但是有些麻烦，还不能在线播放和预览。</p>
<p>在window上可以通过copy这个命令合并两个文件成一个文件。</p>
<p>但是Linux上如何解决呢？</p>
<p>经过查找后，感谢v2ex，有人问过相同的问题。</p>
<p>其实只要在文件末尾后面加二进制的00即可，既不会改变文件的大概性质，还实现了修改md5。</p>
<p>以a.txt演示，命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e -n <span class="string">"\x00"</span> &gt;&gt; 你的文件</span><br></pre></td></tr></table></figure>

<p>演示效果如下：</p>
<p><img src="//pic.oldzhg.com/uPic/aeHTVL.png" alt=""></p>
<p>批量修改当前文件夹下所有文件md5值的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find . -<span class="built_in">type</span> f -<span class="built_in">exec</span> bash -c <span class="string">'echo -e -n "\x00" &gt;&gt; &#123;&#125;'</span> \;</span><br></pre></td></tr></table></figure>





]]></content>
      <tags>
        <tag>Tech</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac 配置Git环境与常用指令</title>
    <url>/2018/09/12/Mac%20%E9%85%8D%E7%BD%AEGit%E7%8E%AF%E5%A2%83%E4%B8%8E%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h4 id="一、Git安装"><a href="#一、Git安装" class="headerlink" title="一、Git安装"></a>一、Git安装</h4><ul>
<li>方法一：下载安装包<a href="https://link.jianshu.com/?t=https://git-scm.com/download" target="_blank" rel="noopener">Git下载地址</a>。</li>
<li>方法二：安装<a href="https://link.jianshu.com/?t=https://brew.sh" target="_blank" rel="noopener">Homebrew</a>，然后通过指令安装<code>brew install git</code>。</li>
</ul>
<h4 id="二、生成密钥"><a href="#二、生成密钥" class="headerlink" title="二、生成密钥"></a>二、生成密钥</h4><p>    Git关联远端仓库时候需要提供公钥，本地保存私钥，每次与远端仓库交互时候，远端仓库会用公钥来验证交互者身份。<br>    生成密钥<code>ssh-keygen -t rsa -C &quot;email address&quot;</code>，根据提示需要选择密钥存放路径。<br>    生成密钥后，在路径下生成两个文件<code>id_rsa</code>、<code>id_rsa.pub</code>，其中<code>id_rsa</code>文件保存的是私钥，放在本地，<code>id_rsa.pub</code>文件是公钥，需要将公钥内容上传到远端仓库，Mac 下直接用文本编辑打开公钥文件。</p>
<h4 id="三、配置提交文件时的用户信息"><a href="#三、配置提交文件时的用户信息" class="headerlink" title="三、配置提交文件时的用户信息"></a>三、配置提交文件时的用户信息</h4><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">git<span class="built_in"> config </span>--global user.name <span class="string">"name"</span></span><br><span class="line">git<span class="built_in"> config </span>--global user.email <span class="string">"email address"</span></span><br></pre></td></tr></table></figure>

<p>配置信息也可以修改，指令与上面的指令相同。使用<code>git config --list</code>查看Git的配置信息。</p>
<h4 id="四、本地关联远端仓库"><a href="#四、本地关联远端仓库" class="headerlink" title="四、本地关联远端仓库"></a>四、本地关联远端仓库</h4><ol>
<li>打开本地文件夹，执行<code>git init</code>命令，初始化文件夹作为本地的一个仓库。</li>
<li>将远端文件 clone 到本地目录，<code>git clone 远端文件URL</code>。</li>
</ol>
<h4 id="五、常用指令"><a href="#五、常用指令" class="headerlink" title="五、常用指令"></a>五、常用指令</h4><p><img src="//pic.oldzhg.com/uPic/QOk2Kt.png" alt="img"></p>
<ul>
<li><strong>名词解释：</strong><br>Workspace：工作区<br>Index / Stage：暂存区<br>Repository：仓库区（或本地仓库）<br>Remote：远程仓库</li>
<li><strong>生成密钥</strong><br><code>ssh-keygen -t rsa -C &quot;email address&quot;</code></li>
<li><strong>配置</strong></li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 显示当前Git 配置</span></span><br><span class="line">git <span class="keyword">config</span> --list </span><br><span class="line"></span><br><span class="line"><span class="comment">// 编辑Git配置文件</span></span><br><span class="line">git <span class="keyword">config</span> -e --<span class="keyword">global</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 配置提交文件时的用户信息</span></span><br><span class="line">git <span class="keyword">config</span> --<span class="keyword">global</span> user<span class="variable">.name</span> <span class="string">"name"</span></span><br><span class="line">git <span class="keyword">config</span> --<span class="keyword">global</span> user<span class="variable">.email</span> <span class="string">"email address"</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>新建一个仓库</strong></li>
</ul>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">// 在当前目录新建一个 Git 仓库</span><br><span class="line">git init </span><br><span class="line"></span><br><span class="line">// 下载项目</span><br><span class="line">git <span class="keyword">clone</span> <span class="title">远端文件URL</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>添加/删除文件</strong></li>
</ul>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加指定文件到暂存区</span></span><br><span class="line"><span class="function"><span class="title">git</span></span> add filename1 filename2 ..... </span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加指定目录及其子目录到暂存区</span></span><br><span class="line">git add dir</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除工作区文件，并且将这次删除放入暂存区</span></span><br><span class="line"><span class="function"><span class="title">git</span></span> rm filename1 filename2 .....</span><br><span class="line"></span><br><span class="line"><span class="comment">// 停止追踪指定文件，但该文件会保留在工作区</span></span><br><span class="line">git rm --cached filename</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>代码提交</strong></li>
</ul>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 提交暂存区到仓库区</span></span><br><span class="line">git commit -m <span class="string">"message"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交暂存区的指定文件到仓库区</span></span><br><span class="line"><span class="function"><span class="title">git</span></span> commit  filename1 filename2 .....  -m <span class="string">"message"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交工作区自上次commit之后的变化，直接到仓库区</span></span><br><span class="line">git commit -a</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交时显示所有diff信息</span></span><br><span class="line">git commit -v</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用一次新的commit，替代上一次提交</span></span><br><span class="line"><span class="comment">// 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span></span><br><span class="line">git commit --amend -m <span class="string">"message"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重做上一次commit，并包括指定文件的新变化</span></span><br><span class="line"><span class="function"><span class="title">git</span></span> commit --amend filename1 filename2 .....</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>分支</strong></li>
</ul>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">// 列出所有本地分支</span><br><span class="line"><span class="symbol">git</span> <span class="keyword">branch</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">// </span>列出所有远程分支</span><br><span class="line"><span class="symbol">git</span> <span class="keyword">branch </span>-r</span><br><span class="line"></span><br><span class="line">// 列出所有本地分支和远程分支</span><br><span class="line"><span class="symbol">git</span> <span class="keyword">branch </span>-a</span><br><span class="line"></span><br><span class="line">// 新建一个分支，但依然停留在当前分支</span><br><span class="line"><span class="symbol">git</span> <span class="keyword">branch </span><span class="keyword">branchname</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">// </span>新建一个分支，并切换到该分支</span><br><span class="line"><span class="symbol">git</span> checkout -<span class="keyword">b </span><span class="keyword">branchname</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">// </span>新建一个分支，指向指定commit</span><br><span class="line"><span class="symbol">git</span> <span class="keyword">branch </span><span class="keyword">branchname </span>commitname</span><br><span class="line"></span><br><span class="line">// 新建一个分支，与指定的远程分支建立追踪关系</span><br><span class="line"><span class="symbol">git</span> <span class="keyword">branch </span>--track <span class="keyword">branchname </span>remotebranch</span><br><span class="line"></span><br><span class="line">// 切换到指定分支，并更新工作区</span><br><span class="line"><span class="symbol">git</span> checkout <span class="keyword">branchname</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">// </span>切换到上一个分支</span><br><span class="line"><span class="symbol">git</span> checkout -</span><br><span class="line"></span><br><span class="line">// 建立追踪关系，在现有分支与指定的远程分支之间</span><br><span class="line"><span class="symbol">git</span> <span class="keyword">branch </span>--set-upstream <span class="keyword">branchname </span>remotebranch</span><br><span class="line"></span><br><span class="line">// 合并指定分支到当前分支</span><br><span class="line"><span class="symbol">git</span> merge <span class="keyword">branchname</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">// </span>选择一个commit，合并进当前分支</span><br><span class="line"><span class="symbol">git</span> cherry-pick commitname</span><br><span class="line"></span><br><span class="line">// 删除分支</span><br><span class="line"><span class="symbol">git</span> <span class="keyword">branch </span>-D <span class="keyword">branchname</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">// </span>删除远程分支</span><br><span class="line"><span class="symbol">git</span> <span class="keyword">push </span>origin --delete <span class="keyword">branchname</span></span><br><span class="line"><span class="keyword">git </span><span class="keyword">branch </span>-dr [remote/<span class="keyword">branch]</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>查看 log</strong></li>
</ul>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">// 显示有变更的文件</span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line">// 显示当前分支的版本历史</span><br><span class="line">git <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line">// 显示commit历史，以及每次commit发生变更的文件</span><br><span class="line">git <span class="built_in">log</span> <span class="comment">--stat</span></span><br><span class="line"></span><br><span class="line">// 搜索提交历史，根据关键词</span><br><span class="line">git <span class="built_in">log</span> -S keyword</span><br><span class="line"></span><br><span class="line">// 显示某个文件的版本历史，包括文件改名</span><br><span class="line">git <span class="built_in">log</span> <span class="comment">--follow filename</span></span><br><span class="line">git whatchanged filename</span><br><span class="line"></span><br><span class="line">// 显示指定文件相关的每一次diff</span><br><span class="line">git <span class="built_in">log</span> -p filename</span><br><span class="line"></span><br><span class="line">// 显示过去<span class="number">5</span>次提交</span><br><span class="line">git <span class="built_in">log</span> <span class="number">-5</span> <span class="comment">--pretty --oneline</span></span><br><span class="line"></span><br><span class="line">// 显示所有提交过的用户，按提交次数排序</span><br><span class="line">git shortlog -sn</span><br><span class="line"></span><br><span class="line">// 显示指定文件是什么人在什么时间修改过</span><br><span class="line">git blame filename</span><br><span class="line"></span><br><span class="line">// 显示暂存区和工作区的差异</span><br><span class="line">git diff</span><br><span class="line"></span><br><span class="line">// 显示暂存区和上一个commit的差异</span><br><span class="line">git diff <span class="comment">--cached filename</span></span><br><span class="line"></span><br><span class="line">// 显示工作区与当前分支最新commit之间的差异</span><br><span class="line">git diff HEAD</span><br><span class="line"></span><br><span class="line">// 显示两次提交之间的差异</span><br><span class="line">git diff [<span class="keyword">first</span>-branch]...[<span class="keyword">second</span>-branch]</span><br><span class="line"></span><br><span class="line">// 显示今天你写了多少行代码</span><br><span class="line">git diff <span class="comment">--shortstat "@&#123;0 day ago&#125;"</span></span><br><span class="line"></span><br><span class="line">// 显示某次提交的元数据和内容变化</span><br><span class="line">git show [commit]</span><br><span class="line"></span><br><span class="line">// 显示某次提交发生变化的文件</span><br><span class="line">git show <span class="comment">--name-only [commit]</span></span><br><span class="line"></span><br><span class="line">// 显示某次提交时，某个文件的内容</span><br><span class="line">git show [commit]: filename</span><br><span class="line"></span><br><span class="line">// 显示当前分支的最近几次提交</span><br><span class="line">git reflog</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>远程同步</strong></li>
</ul>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下载远程仓库的所有变动</span></span><br><span class="line"><span class="selector-tag">git</span> <span class="selector-tag">fetch</span> <span class="selector-attr">[remote]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示所有远程仓库</span></span><br><span class="line"><span class="selector-tag">git</span> <span class="selector-tag">remote</span> <span class="selector-tag">-v</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示某个远程仓库的信息</span></span><br><span class="line"><span class="selector-tag">git</span> <span class="selector-tag">remote</span> <span class="selector-tag">show</span> <span class="selector-attr">[remote]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加一个新的远程仓库，并命名</span></span><br><span class="line"><span class="selector-tag">git</span> <span class="selector-tag">remote</span> <span class="selector-tag">add</span> <span class="selector-attr">[shortname]</span> <span class="selector-attr">[url]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 取回远程仓库的变化，并与本地分支合并</span></span><br><span class="line"><span class="selector-tag">git</span> <span class="selector-tag">pull</span> <span class="selector-attr">[remote]</span> <span class="selector-tag">branchname</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上传本地指定分支到远程仓库</span></span><br><span class="line"><span class="selector-tag">git</span> <span class="selector-tag">push</span> <span class="selector-attr">[remote]</span> <span class="selector-tag">branchname</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 强行推送当前分支到远程仓库，即使有冲突</span></span><br><span class="line"><span class="selector-tag">git</span> <span class="selector-tag">push</span> <span class="selector-attr">[remote]</span> <span class="selector-tag">--force</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 推送所有分支到远程仓库</span></span><br><span class="line"><span class="selector-tag">git</span> <span class="selector-tag">push</span> <span class="selector-attr">[remote]</span> <span class="selector-tag">--all</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>撤销</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">// 恢复暂存区的指定文件到工作区</span><br><span class="line">git checkout filename</span><br><span class="line"></span><br><span class="line">// 恢复某个<span class="keyword">commit</span>的指定文件到暂存区和工作区</span><br><span class="line">git checkout [<span class="keyword">commit</span>] filename</span><br><span class="line"></span><br><span class="line">// 恢复暂存区的所有文件到工作区</span><br><span class="line">git checkout .</span><br><span class="line"></span><br><span class="line">// 重置暂存区的指定文件，与上一次<span class="keyword">commit</span>保持一致，但工作区不变</span><br><span class="line">git <span class="keyword">reset</span> filename</span><br><span class="line"></span><br><span class="line">// 重置暂存区与工作区，与上一次<span class="keyword">commit</span>保持一致</span><br><span class="line">git <span class="keyword">reset</span> <span class="comment">--hard</span></span><br><span class="line"></span><br><span class="line">// 重置当前分支的指针为指定<span class="keyword">commit</span>，同时重置暂存区，但工作区不变</span><br><span class="line">git <span class="keyword">reset</span> [<span class="keyword">commit</span>]</span><br><span class="line"></span><br><span class="line">// 重置当前分支的<span class="keyword">HEAD</span>为指定<span class="keyword">commit</span>，同时重置暂存区和工作区，与指定<span class="keyword">commit</span>一致</span><br><span class="line">git <span class="keyword">reset</span> <span class="comment">--hard [commit]</span></span><br><span class="line"></span><br><span class="line">// 重置当前<span class="keyword">HEAD</span>为指定<span class="keyword">commit</span>，但保持暂存区和工作区不变</span><br><span class="line">git <span class="keyword">reset</span> <span class="comment">--keep [commit]</span></span><br><span class="line"></span><br><span class="line">// 新建一个<span class="keyword">commit</span>，用来撤销指定<span class="keyword">commit</span></span><br><span class="line">// 后者的所有变化都将被前者抵消，并且应用到当前分支</span><br><span class="line">git revert [<span class="keyword">commit</span>]</span><br><span class="line"></span><br><span class="line">// 暂时将未提交的变化移除，稍后再移入</span><br><span class="line">git stash</span><br><span class="line">git stash pop</span><br></pre></td></tr></table></figure>

<h4 id="六、遇到的问题"><a href="#六、遇到的问题" class="headerlink" title="六、遇到的问题"></a>六、遇到的问题</h4><ol>
<li>拒绝访问</li>
</ol>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">Permission denied (publickey).</span><br><span class="line">fatal: Could <span class="keyword">not</span> <span class="built_in">read</span> <span class="built_in">from</span> remote repository.</span><br><span class="line">Please make sure you have <span class="keyword">the</span> correct access rights</span><br><span class="line"><span class="keyword">and</span> <span class="keyword">the</span> repository exists.</span><br></pre></td></tr></table></figure>

<p>解决方法：<code>ssh-add 私钥路径</code>，其中<code>ssh-add</code>命令是把专用密钥添加到ssh-agent的高速缓存中。</p>
<ol>
<li>执行 <code>git branch -a</code>看不到新创建的分支<br>原因：这条命令并没有每一次都从远程更新仓库信息。<br>解决方法：手动刷新仓库信息<code>git fetch origin</code>。</li>
</ol>
<h2 id="七、参考链接"><a href="#七、参考链接" class="headerlink" title="七、参考链接"></a>七、参考链接</h2><ul>
<li><a href="https://link.jianshu.com/?t=https://git-scm.com/book/zh/v2" target="_blank" rel="noopener">Git官方中文手册</a></li>
<li><a href="https://link.jianshu.com/?t=http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="noopener">阮一峰的网络日志 - 常用 Git 命令清单</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Linux系统下实现远程连接MySQL数据库的方法教程</title>
    <url>/2020/03/13/Linux-connect-Mysql-remote/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h3><p>最近在工作中遇到了这个需求，估计搞了一个多小时才把这个远程连接搞好。一台本地电脑，一台云服务器，都是linux系统。下面来看看详细的介绍：</p>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a><strong>步骤</strong></h3><h4 id="1、在服务器端开启远程访问"><a href="#1、在服务器端开启远程访问" class="headerlink" title="1、在服务器端开启远程访问"></a><strong>1、在服务器端开启远程访问</strong></h4><p>首先进入mysql数据库，然后输入下面两个命令：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grant all privileges on *.* to <span class="string">'root'</span>@<span class="string">'%'</span> identified by <span class="string">'你的密码'</span>;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>

<p>第一个*是数据库，可以改成允许访问的数据库名称  </p>
<p>第二个 是数据库的表名称，代表允许访问任意的表  </p>
<p>root代表远程登录使用的用户名，可以自定义  </p>
<p>%代表允许任意ip登录，如果你想指定特定的IP，可以把%替换掉就可以了  </p>
<p><strong>password代表远程登录时使用的密码，可以自定义</strong>  </p>
<p>flush privileges;这是让权限立即生效  </p>
<h4 id="2、修改my-cnf配置文件"><a href="#2、修改my-cnf配置文件" class="headerlink" title="2、修改my.cnf配置文件"></a><strong>2、修改my.cnf配置文件</strong></h4><p>这个是mysql的配置文件，如果你找不到在哪里的话，可以输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">`find /* -name my.cnf`</span><br></pre></td></tr></table></figure>

<p>通过vim编辑该文件，找到<code>bind-address    = 127.0.0.1 或者是 0.0.0.0</code>这一句</p>
<p>然后在前面加个#号注释掉，保存退出</p>
<h4 id="3、重启服务"><a href="#3、重启服务" class="headerlink" title="3、重启服务"></a><strong>3、重启服务</strong></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service mysql restart</span><br></pre></td></tr></table></figure>

<h4 id="4、在本地远程连接"><a href="#4、在本地远程连接" class="headerlink" title="4、在本地远程连接"></a><strong>4、在本地远程连接</strong></h4><p>在终端输入：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -h 服务器ip地址 -P 3306 -u root -p</span><br></pre></td></tr></table></figure>

<p>然后输入密码即可。  </p>
<p>root是第1点设置的用户名，密码也是第1点设置的密码  , 注意第一个P指定端口是大写</p>
<h3 id="一些细节"><a href="#一些细节" class="headerlink" title="一些细节"></a><strong>一些细节</strong></h3><p>在网上找了很多文章，说要开启3306端口才能连接，但是我开启了却还是无法连接，后来又找到了一些文章，说要更改my.cnf，也就是上面的第2点，更改了然后重启服务器就可以了。</p>
<p>刚刚在另外一台服务器上面试了一下，没有配置过端口，通过上面三步，很快就连上了。</p>
<p>所以第二点非常重要，基本上每个人装mysql的时候都会去配置那个文件，因为字符集需要配置。所以肯定有那个文件的，用find命令找找就行了。</p>
]]></content>
      <tags>
        <tag>Tech</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac修改主机名和计算机名</title>
    <url>/2018/11/24/Mac%E4%BF%AE%E6%94%B9%E4%B8%BB%E6%9C%BA%E5%90%8D%E5%92%8C%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%90%8D/</url>
    <content><![CDATA[<h2 id="OS-X-下主机名和计算机名是不同的概念"><a href="#OS-X-下主机名和计算机名是不同的概念" class="headerlink" title="OS X 下主机名和计算机名是不同的概念"></a>OS X 下主机名和计算机名是不同的概念</h2><p>通常意义上的主机名就是指在同一局域网内用来标识不同主机的名称。对于 Windows 用户来说，就是在“网络”内可以让同一局域网内其他用户看到的自己的计算机名称。所以自己的计算机名称，也就是主机名，用户可以在“计算机”的属性设置内自定义。</p>
<p><strong>但对于 Mac OS 来说，主机名和计算机名是不同的概念，因为 Mac OS 可以通过“计算机名”来自定义主机在局域网内显示的名称，也就是我们前面所说的通常意义上的主机名。而 Mac OS 下的“主机名”才是主机真正的名称。</strong></p>
<p>如果你了解 Unix 或者 Linux，应该很清楚，终端下的命令提示符是可以自定义的，通常命令提示符包含主机名，也就是当前终端连接的主机的名称。</p>
<p>对于 Mac OS 下的终端来说，此时显示的“主机名”就是 <strong>HostName</strong>，也就是主机真正的名称，我们可以通过命令查看当前的“主机名”：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$HOSTNAME</span></span><br></pre></td></tr></table></figure>

<p>如果要修改主机名，可以使用下面的命令：</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">sudo scutil --<span class="keyword">set</span> HostName 新的主机名</span><br></pre></td></tr></table></figure>

<p>执行命令后，再输入 <code>exit</code> 结束当前终端进程。重新打开终端，就会发现主机名已经修改为新的主机名了。</p>
<p>那么怎么自定义当前主机在局域网内显示的主机名呢？</p>
<p>我们通过自定义 Mac OS 下的“计算机名”，即 <strong>ComputerName</strong> 值来实现。有两种方法：</p>
<ul>
<li>1.在“设置”——“共享”下，修改电脑名称。</li>
<li>2.在终端下，通过命令实现。</li>
</ul>
<p>具体实现过程为：</p>
<p>方法1 - 在“设置”——“共享”下，修改电脑名称:</p>
<img src="//pic.oldzhg.com/uPic/wtoGvK.png" style="zoom:50%;" />

<p>方法2 - 在终端下输入命令：</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">sudo scutil --<span class="keyword">set</span> ComputerName 新的计算机名</span><br></pre></td></tr></table></figure>

<p>修改后，再在“设置”——“共享”下勾选“远程登录”，同一局域网内的其他终端就能通过 <code>ssh</code> 命令登录该主机了。这不在本文的讨论范围，所以不具体说明了。</p>
]]></content>
      <tags>
        <tag>Tech</tag>
      </tags>
  </entry>
  <entry>
    <title>MediaWiki</title>
    <url>/2020/08/07/MediaWiki/</url>
    <content><![CDATA[<h2 id="安装运行环境"><a href="#安装运行环境" class="headerlink" title="安装运行环境"></a>安装运行环境</h2><p>这里建议<a href="https://oneinstack.com" target="_blank" rel="noopener">onestack</a>一键脚本搭建LNMP环境</p>
<h2 id="下载MediaWiki"><a href="#下载MediaWiki" class="headerlink" title="下载MediaWiki"></a>下载MediaWiki</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://releases.wikimedia.org/mediawiki/1.29/mediawiki-1.29.1.tar.gz</span><br><span class="line">tar -zxvf mediawiki-1.29.1.tar.gz</span><br></pre></td></tr></table></figure>

<h2 id="配置nginx"><a href="#配置nginx" class="headerlink" title="配置nginx"></a>配置nginx</h2><p>修改一下目录的权限</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chown -R www /data/wwwroot/mediawiki</span><br></pre></td></tr></table></figure>

<p>再改一下nginx.conf的默认目录到mediawiki</p>
<h2 id="安装MediaWiki"><a href="#安装MediaWiki" class="headerlink" title="安装MediaWiki"></a>安装MediaWiki</h2><p>输入公网ip就可以啦，按照指示很快就能弄好</p>
<p><img src="https://pic.oldzhg.com/uPic/BPWBCn.png" alt=""></p>
<p>安装成功的样子</p>
<p><img src="https://oss.oldzhg.com/uPic/Xnip2020-08-07_20-09-05.jpg" alt="Xnip2020-08-07_20-09-05"></p>
]]></content>
      <categories>
        <category>ECS七天训练营</category>
      </categories>
  </entry>
  <entry>
    <title>Markdown基本语法</title>
    <url>/2020/03/30/Markdown-basic-syntax/</url>
    <content><![CDATA[<h1 id="Markdown简介"><a href="#Markdown简介" class="headerlink" title="Markdown简介"></a>Markdown简介</h1><p>Markdown是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。</p>
<p>相比WYSIWYG编辑器</p>
<p><strong>优点：</strong><br>1、因为是纯文本，所以只要支持Markdown的地方都能获得一样的编辑效果，可以让作者摆脱排版的困扰，专心写作。<br>2、操作简单。比如:WYSIWYG编辑时标记个标题，先选中内容，再点击导航栏的标题按钮，选择几级标题。要三个步骤。而Markdown只需要在标题内容前加#即可</p>
<p><strong>缺点：</strong><br>1、需要记一些语法（当然，是很简单。五分钟学会）。<br>2、有些平台不支持Markdown编辑模式。</p>
<p>还好，简书是支持Markdown编辑模式的。</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">开启方式：设置-&gt;默认编辑器-&gt;Markdown编辑器</span><br></pre></td></tr></table></figure>

<h1 id="Markdown基本使用"><a href="#Markdown基本使用" class="headerlink" title="Markdown基本使用"></a>Markdown基本使用</h1><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>在想要设置为标题的文字前面加#来表示<br>一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。</p>
<p>注：标准语法一般在#后跟个空格再写文字，貌似简书不加空格也行。</p>
<p>示例：</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"># 这是一级标题</span><br><span class="line">## 这是二级标题</span><br><span class="line">### 这是三级标题</span><br><span class="line">#### 这是四级标题</span><br><span class="line">##### 这是五级标题</span><br><span class="line">###### 这是六级标题</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<h2 id="这是二级标题"><a href="#这是二级标题" class="headerlink" title="这是二级标题"></a>这是二级标题</h2><h3 id="这是三级标题"><a href="#这是三级标题" class="headerlink" title="这是三级标题"></a>这是三级标题</h3><h4 id="这是四级标题"><a href="#这是四级标题" class="headerlink" title="这是四级标题"></a>这是四级标题</h4><h5 id="这是五级标题"><a href="#这是五级标题" class="headerlink" title="这是五级标题"></a>这是五级标题</h5><h6 id="这是六级标题"><a href="#这是六级标题" class="headerlink" title="这是六级标题"></a>这是六级标题</h6><hr>
<h2 id="段落格式"><a href="#段落格式" class="headerlink" title="段落格式"></a>段落格式</h2><ul>
<li><h5 id="加粗"><a href="#加粗" class="headerlink" title="加粗"></a>加粗</h5></li>
</ul>
<p>要加粗的文字左右分别用两个*号包起来</p>
<ul>
<li><h5 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h5></li>
</ul>
<p>要倾斜的文字左右分别用一个*号包起来</p>
<ul>
<li><h5 id="斜体加粗"><a href="#斜体加粗" class="headerlink" title="斜体加粗"></a>斜体加粗</h5></li>
</ul>
<p>要倾斜和加粗的文字左右分别用三个*号包起来</p>
<ul>
<li><h5 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h5></li>
</ul>
<p>要加删除线的文字左右分别用两个~~号包起来</p>
<p>示例：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">*<span class="strong">*这是加粗的文字*</span><span class="strong">*</span></span><br><span class="line"><span class="strong">*</span>这是倾斜的文字<span class="strong">*`</span></span><br><span class="line"><span class="strong">*</span>*<span class="strong">*这是斜体加粗的文字*</span>*<span class="strong">*</span></span><br><span class="line"><span class="strong">~~这是加删除线的文字~~</span></span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><strong>这是加粗的文字</strong><br><em>这是倾斜的文字</em><br><strong><em>这是斜体加粗的文字</em></strong><br><del>这是加删除线的文字</del></p>
<hr>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;<br>n个…<br>貌似可以一直加下去，但没神马卵用</p>
<p>示例：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">&gt;这是引用的内容</span><br><span class="line"><span class="meta">&gt;&gt;</span>这是引用的内容</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<blockquote>
<p>这是引用的内容</p>
<blockquote>
<p>这是引用的内容</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>这是引用的内容</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>三个或者三个以上的 - 或者 * 都可以。</p>
<p>示例：</p>
<p>效果如下：<br>可以看到，显示效果是一样的。</p>
<hr>
<hr>
<hr>
<hr>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>语法：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">图片alt</span>](<span class="link">图片地址 ''图片title''</span>)</span><br><span class="line"></span><br><span class="line">图片alt就是显示在图片下面的文字，相当于对图片内容的解释。</span><br><span class="line">图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">![blockchain](https:<span class="comment">//ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/</span></span><br><span class="line">u=<span class="number">702257389</span>,<span class="number">1274025419</span>&amp;fm=<span class="number">27</span>&amp;gp=<span class="number">0.</span>jpg <span class="string">"区块链"</span>)</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img src="//pic.oldzhg.com/uPic/1j43ZZ.jpg" alt="blockchain"></p>
<p>上传本地图片直接点击导航栏的图片标志，选择图片即可**</p>
<p>markdown格式追求的是简单、多平台统一。那么图片的存储就是一个问题，需要用图床，提供统一的外链，这样就不用在不同的平台去处理图片的问题了。才能做到书写一次，各处使用。<br>关于图床的选择我写了一篇文章，对网上存在的各种方法做了总结，需要的朋友可以看看。<a href="https://www.jianshu.com/p/ea1eb11db63f" target="_blank" rel="noopener">markdown图床</a></p>
<h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p>语法：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">超链接名</span>](<span class="link">超链接地址 "超链接title"</span>)</span><br><span class="line">title可加可不加</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">简书</span>](<span class="link">http://jianshu.com</span>)</span><br><span class="line">[<span class="string">百度</span>](<span class="link">http://baidu.com</span>)</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><a href="https://www.jianshu.com/u/1f5ac0cf6a8b" target="_blank" rel="noopener">简书</a><br><a href="https://links.jianshu.com/go?to=http%3A%2F%2Fbaidu.com" target="_blank" rel="noopener">百度</a></p>
<p>注：Markdown本身语法不支持链接在新页面中打开，貌似简书做了处理，是可以的。别的平台可能就不行了，如果想要在新页面中打开的话可以用html语言的a标签代替。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;a <span class="attribute">href</span>=<span class="string">"超链接地址"</span> <span class="attribute">target</span>=<span class="string">"_blank"</span>&gt;超链接名&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">示例</span><br><span class="line">&lt;a <span class="attribute">href</span>=<span class="string">"https://www.jianshu.com/u/1f5ac0cf6a8b"</span> <span class="attribute">target</span>=<span class="string">"_blank"</span>&gt;简书&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><p>语法：<br>无序列表用 - + * 任何一种都可以</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">- </span>列表内容</span><br><span class="line"><span class="bullet">+ </span>列表内容</span><br><span class="line"><span class="bullet">* </span>列表内容</span><br><span class="line"></span><br><span class="line">注意：- + * 跟内容之间都要有一个空格</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<ul>
<li>列表内容</li>
<li>列表内容</li>
<li>列表内容</li>
</ul>
<h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><p>语法：<br>数字加点</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 列表内容</span><br><span class="line"><span class="number">2.</span> 列表内容</span><br><span class="line"><span class="number">3.</span> 列表内容</span><br><span class="line"></span><br><span class="line">注意：序号跟内容之间要有空格</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<ol>
<li>列表内容</li>
<li>列表内容</li>
<li>列表内容</li>
</ol>
<h2 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h2><p><strong>上一级和下一级之间敲三个空格即可</strong></p>
<ul>
<li><p>一级无序列表内容</p>
<ul>
<li>二级无序列表内容</li>
<li>二级无序列表内容</li>
<li>二级无序列表内容</li>
</ul>
</li>
<li><p>一级无序列表内容</p>
<ol>
<li>二级有序列表内容</li>
<li>二级有序列表内容</li>
<li>二级有序列表内容</li>
</ol>
</li>
</ul>
<ol>
<li><p>一级有序列表内容</p>
<ul>
<li>二级无序列表内容</li>
<li>二级无序列表内容</li>
<li>二级无序列表内容</li>
</ul>
</li>
<li><p>一级有序列表内容</p>
<ol>
<li>二级有序列表内容</li>
<li>二级有序列表内容</li>
<li>二级有序列表内容</li>
</ol>
</li>
</ol>
<hr>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>语法：</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">表头|<span class="string">表头</span>|<span class="string">表头</span></span><br><span class="line"><span class="string">---</span>|<span class="string">:--:</span>|<span class="string">---:</span></span><br><span class="line"><span class="string">内容</span>|<span class="string">内容</span>|<span class="string">内容</span></span><br><span class="line"><span class="string">内容</span>|<span class="string">内容</span>|<span class="string">内容</span></span><br><span class="line"></span><br><span class="line"><span class="string">第二行分割表头和内容。</span></span><br><span class="line"><span class="string">- 有一个就行，为了对齐，多加了几个</span></span><br><span class="line"><span class="string">文字默认居左</span></span><br><span class="line"><span class="string">-两边加：表示文字居中</span></span><br><span class="line"><span class="string">-右边加：表示文字居右</span></span><br><span class="line"><span class="string">注：原生的语法两边都要用 </span>|<span class="string"> 包起来。此处省略</span></span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">姓名|<span class="string">技能</span>|<span class="string">排行</span></span><br><span class="line"><span class="string">--</span>|<span class="string">:--:</span>|<span class="string">--:</span></span><br><span class="line"><span class="string">刘备</span>|<span class="string">哭</span>|<span class="string">大哥</span></span><br><span class="line"><span class="string">关羽</span>|<span class="string">打</span>|<span class="string">二哥</span></span><br><span class="line"><span class="string">张飞</span>|<span class="string">骂</span>|<span class="string">三弟</span></span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<table>
<thead>
<tr>
<th>姓名</th>
<th>技能</th>
<th>排行</th>
</tr>
</thead>
<tbody><tr>
<td>刘备</td>
<td>哭</td>
<td>大哥</td>
</tr>
<tr>
<td>关羽</td>
<td>打</td>
<td>二哥</td>
</tr>
<tr>
<td>张飞</td>
<td>骂</td>
<td>三弟</td>
</tr>
</tbody></table>
<p>语法：<br>单行代码：代码之间分别用一个反引号包起来</p>
<p>代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行</p>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line">(```)</span><br><span class="line">  代码...</span><br><span class="line">  代码...</span><br><span class="line">  代码...</span><br><span class="line">(```)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可。</p>
</blockquote>
<p>示例：</p>
<p>单行代码</p>
<p>代码块</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">(```)</span><br><span class="line">    function <span class="function"><span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">         echo <span class="string">"这是一句非常牛逼的代码"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">fun</span><span class="params">()</span></span>;</span><br><span class="line">(```)</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p>单行代码</p>
<p><code>create database hero;</code></p>
<p>代码块</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">function <span class="function"><span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">  echo <span class="string">"这是一句非常牛逼的代码"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">fun</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">st=&gt;start: 开始</span><br><span class="line">op=&gt;operation: My Operation</span><br><span class="line">cond=&gt;condition: Yes <span class="keyword">or</span> No?</span><br><span class="line">e=&gt;end</span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond<span class="function"><span class="params">(<span class="literal">yes</span>)</span>-&gt;</span>e</span><br><span class="line">cond<span class="function"><span class="params">(<span class="literal">no</span>)</span>-&gt;</span>op</span><br><span class="line">&amp;``<span class="javascript"><span class="string">`</span></span></span><br></pre></td></tr></table></figure>

<p>效果如下：    </p>
<p><img src="//pic.oldzhg.com/uPic/ugJWHL.png" alt="流程图.png"></p>
]]></content>
      <categories>
        <category>工具技巧</category>
      </categories>
      <tags>
        <tag>Tech</tag>
      </tags>
  </entry>
  <entry>
    <title>New MacBook Pro</title>
    <url>/2018/11/24/New_MacBook_Pro/</url>
    <content><![CDATA[<p>首先，我们安装 macOS Command Line Tools。</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">xcode-<span class="keyword">select</span> <span class="comment">--install</span></span><br></pre></td></tr></table></figure>

<p>然后去App Store下载Xcode，安装完毕后打开Xcode并同意许可内容</p>
<p><a href="https://brew.sh/" target="_blank" rel="noopener">Homebrew</a> 是 macOS 中必备的包管理工具。通过 Homebrew 可以无需 root 一键安装各类软件，省去复杂的依赖管理和编译参数配置。</p>
<p>同时，Homebrew Cask 还可以安装非命令行编译类程序，也就是平时日常用的软件都可以用 Homebrew Cask 进行安装。</p>
<p>Homebrew 强大的能力让自动初始化的第一步成为可能。</p>
<p>所以第一步，我们先安装 Homebrew：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">/usr/bin/ruby -e <span class="string">"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"</span></span><br></pre></td></tr></table></figure>

<p>安装常用软件及工具</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment">#安装工具</span></span><br><span class="line">brew update &amp;&amp; brew install python3 wget cmake</span><br><span class="line"><span class="comment">#安装应用程序</span></span><br><span class="line">brew cask install google-chrome sublime-text iterm2 dash iina hyperswitch karabiner-elements</span><br></pre></td></tr></table></figure>

<p>安装oh my zsh</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sh -c <span class="string">"<span class="variable">$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)</span>"</span></span><br></pre></td></tr></table></figure>

<p>下载完成后编辑<code>.zshrc</code>文件并指定主题为<code>agnoster</code></p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">vim ~/.zshrc</span><br><span class="line"><span class="builtin-name">set</span> <span class="attribute">ZSH_THEME</span>=<span class="string">"agnoster"</span></span><br></pre></td></tr></table></figure>

<p>安装Powerlevel9k主题</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">git clone https:<span class="regexp">//gi</span>thub.com<span class="regexp">/bhilburn/</span>powerlevel9k.git ~<span class="regexp">/.oh-my-zsh/</span>custom<span class="regexp">/themes/</span>powerlevel9k</span><br></pre></td></tr></table></figure>

<p>下载完成后编辑<code>.zashrc</code>文件并指定主题</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">vim ~/.zshrc</span><br><span class="line"><span class="builtin-name">set</span> <span class="attribute">ZSH_THEME</span>=<span class="string">"powerlevel9k/powerlevel9k"</span>.</span><br></pre></td></tr></table></figure>

<p>安装插件</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">cd</span> ~<span class="string">/.oh-my-zsh/custom/plugins/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#incr</span></span><br><span class="line">mkdir ~<span class="string">/.oh-my-zsh/plugins/incr</span></span><br><span class="line">wget http:<span class="string">//mimosa-pudica.net/src/incr-0.2.zsh</span> -O ~<span class="string">/.oh-my-zsh/plugins/incr/incr.plugin.zsh</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#zsh-syntax-highlighting</span></span><br><span class="line">git clone https:<span class="string">//github.com/zsh-users/zsh-syntax-highlighting.git</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#zsh-autosuggestions</span></span><br><span class="line">git clone https:<span class="string">//github.com/zsh-users/zsh-autosuggestions</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#autojump</span></span><br><span class="line">brew install zsh-autosuggestions autojump</span><br><span class="line">source <span class="string">/usr/local/share/zsh-autosuggestions/zsh-autosuggestions.zsh</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#把以上插件加入到 plugins 中</span></span><br><span class="line">vi ~<span class="string">/.zshrc</span></span><br><span class="line">在文件的最后一行添加：source ~<span class="string">/.oh-my-zsh/custom/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh</span></span><br></pre></td></tr></table></figure>

<p>编辑插件内容如图，请务必保证插件顺序，zsh-syntax-highlighting必须在最后一个。</p>
<p><img src="/Users/oldzhg/Documents/120393975-5b0511fcbec18_articlex.png" alt="120393975-5b0511fcbec18_articlex"></p>
<p>若当前登入的帐号为你的帐号xxx，就不用特别显示出来</p>
<p>DEFAULT_USER=”biyongyao”</p>
<h3 id="vim-plug"><a href="#vim-plug" class="headerlink" title="vim-plug"></a>vim-plug</h3><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><p>vim-plug的安装非常简单，一行命令完事。或者也可以将<a href="https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim" target="_blank" rel="noopener">plug.vim</a>中的内容复制到<code>~/.vim/autoload/plug.vim</code>中。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">curl -fLo ~/.<span class="keyword">vim</span>/autoload/plug.<span class="keyword">vim</span> --create-dirs \</span><br><span class="line">http<span class="variable">s:</span>//raw.githubusercontent.<span class="keyword">com</span>/junegunn/<span class="keyword">vim</span>-plug/master/plug.<span class="keyword">vim</span></span><br></pre></td></tr></table></figure>

<h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><p>使用vim-plug管理vim插件非常简单，具体命令见<a href="https://github.com/junegunn/vim-plug" target="_blank" rel="noopener">vim-plug command</a>。我们需要安装YCM插件，只需要在<code>~/.vimrc</code>文件中加入如下。</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line"><span class="built_in">call</span> plug<span class="meta">#begin(<span class="string">'~/.vim/plugged'</span>)</span></span><br><span class="line">Plug <span class="string">'Valloric/YouCompleteMe'</span>, &#123; <span class="string">'do'</span>: <span class="string">'./install.py --clang-completer'</span>,  <span class="string">'for'</span>: [<span class="string">'c'</span>, <span class="string">'cpp'</span>] &#125;</span><br><span class="line"><span class="built_in">call</span> plug<span class="meta">#end()</span></span><br></pre></td></tr></table></figure>

<p>其中<code>&#39;do&#39;</code>后面跟的命令是指YCM插件在使用vim-plug安装后，还需要执行的额外的命令（该命令在后面有解释），这也是YCM插件安装起来麻烦的原因。<code>‘for’</code>后面跟的内容是指YCM插件只在打开c和cpp文件时才会被激活。<br>接下来就可以在vim命令行中运行<code>PlugInstall</code>命令安装YCM</p>
<p>最后，还需要配置下YCM才可以正常使用，官方提供了一个默认的配置文件，号称可以解决99%的需求。在<code>.vimrc</code>文件中加入一行进行设置即可。YCM的配置非常丰富，具体可参考<a href="https://github.com/Valloric/YouCompleteMe" target="_blank" rel="noopener">YCM</a>。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_global_ycm_extra_conf</span>=<span class="string">'~/.vim/plugged/YouCompleteMe/third_party/ycmd/.ycm_extra_conf.py'</span></span><br></pre></td></tr></table></figure>

<h4 id="更新插件"><a href="#更新插件" class="headerlink" title="更新插件"></a>更新插件</h4><p>要更新插件，请运行：</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line"><span class="symbol">:PlugUpdate</span></span><br></pre></td></tr></table></figure>

<p>更新插件后，按下 <code>d</code> 查看更改。或者，你可以之后输入 <code>:PlugDiff</code>。</p>
<h4 id="审查插件"><a href="#审查插件" class="headerlink" title="审查插件"></a>审查插件</h4><p>有时，更新的插件可能有新的 bug 或无法正常工作。要解决这个问题，你可以简单地回滚有问题的插件。输入 <code>:PlugDiff</code> 命令，然后按回车键查看上次 <code>:PlugUpdate</code>的更改，并在每个段落上按 <code>X</code> 将每个插件回滚到更新前的前一个状态。</p>
<h4 id="删除插件"><a href="#删除插件" class="headerlink" title="删除插件"></a>删除插件</h4><p>删除一个插件删除或注释掉你以前在你的 vim 配置文件中添加的 <code>plug</code> 命令。然后，运行 <code>:source ~/.vimrc</code> 或重启 Vim 编辑器。最后，运行以下命令卸载插件：</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line"><span class="symbol">:PlugClean</span></span><br></pre></td></tr></table></figure>

<p>该命令将删除 vim 配置文件中所有未声明的插件。</p>
<h4 id="升级-Vim-plug"><a href="#升级-Vim-plug" class="headerlink" title="升级 Vim-plug"></a>升级 Vim-plug</h4><p>要升级vim-plug本身，请输入：</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line"><span class="symbol">:PlugUpgrade</span></span><br></pre></td></tr></table></figure>


]]></content>
      <tags>
        <tag>Mac</tag>
        <tag>准备</tag>
      </tags>
  </entry>
  <entry>
    <title>Sublime Text3 使用技巧教程</title>
    <url>/2018/05/07/Sublime%20Text3%20%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="1、快速查找-amp-替换"><a href="#1、快速查找-amp-替换" class="headerlink" title="1、快速查找&amp;替换"></a>1、快速查找&amp;替换</h2><p>多数情况下，我们需要查找文中某个关键字出现的其它位置，这时并不需要重新将该关键字重新输入一遍然后搜索，我们只需要使用 <code>Ctrl + D</code> 选中关键字，再次 <code>Ctrl + D</code> 或者使用 <code>F3</code> 选择该词出现的下一个位置，<code>Shift + F3</code> 跳到其上一个出现位置，此外还可以用 <code>Alt + F3</code> 选中其出现的所有位置（之后可以进行多重编辑，也就是快速替换）。</p>
<h2 id="2、快速打开文件"><a href="#2、快速打开文件" class="headerlink" title="2、快速打开文件"></a>2、快速打开文件</h2><p><code>Ctrl+P</code> 快捷键可以快速打开文件，输入文件名称即可切换打开了，因为可能我们一次打开的窗口比较多，<code>Ctrl+P</code> 快捷键可以快速的切换到相应的文件。</p>
<h2 id="3、打开整个工程"><a href="#3、打开整个工程" class="headerlink" title="3、打开整个工程"></a>3、打开整个工程</h2><p>文件——》打开文件夹——》选择自己的工程，可以打开整个工程，这里的话就可以在整个工程里边查看所有文件了，修改方便。你也可以直接将文件夹拖到侧边栏中。</p>
<h2 id="4、快捷键列表（Shortcuts-Cheatsheet）"><a href="#4、快捷键列表（Shortcuts-Cheatsheet）" class="headerlink" title="4、快捷键列表（Shortcuts Cheatsheet）"></a>4、快捷键列表（Shortcuts Cheatsheet）</h2><h4 id="通用（General）"><a href="#通用（General）" class="headerlink" title="通用（General）"></a>通用（General）</h4><ul>
<li>↑↓←→：上下左右移动光标，vim编辑模式下可以使用KJHL。</li>
<li>Ctrl + /：注释</li>
<li>Alt：调出菜单</li>
<li>Ctrl + Shift + P：调出命令板（Command Palette）</li>
<li>Ctrl + `：调出控制台</li>
<li>Ctrl + k + b   、Ctrl + k,Ctrl + b：打开、关闭侧边栏</li>
</ul>
<h4 id="编辑（Editing）"><a href="#编辑（Editing）" class="headerlink" title="编辑（Editing）"></a>编辑（Editing）</h4><ul>
<li>Ctrl + Enter：在当前行下面新增一行然后跳至该行</li>
<li>Ctrl + Shift + Enter：在当前行上面增加一行并跳至该行</li>
<li>Ctrl + ←/→：进行逐词移动</li>
<li>Ctrl + Shift + ←/→进行逐词选择</li>
<li>Ctrl + ↑/↓移动当前显示区域</li>
<li>Ctrl + Shift + ↑/↓移动当前行</li>
</ul>
<h4 id="选择（Selecting）"><a href="#选择（Selecting）" class="headerlink" title="选择（Selecting）"></a>选择（Selecting）</h4><ul>
<li>Ctrl + D：选择当前光标所在的词并高亮该词所有出现的位置，再次Ctrl + D选择该词出现的下一个位置，在多重选词的过程中，使用Ctrl + K进行跳过，使用Ctrl + U进行回退，使用Esc退出多重编辑</li>
<li>Ctrl + Shift + L：将当前选中区域打散</li>
<li>Ctrl + J：把当前选中区域合并为一行</li>
<li>Ctrl + M：在起始括号和结尾括号间切换</li>
<li>Ctrl + Shift + M：快速选择括号间的内容</li>
<li>Ctrl + Shift + J：快速选择同缩进的内容</li>
<li>Ctrl + Shift + Space：快速选择当前作用域（Scope）的内容</li>
</ul>
<h4 id="查找-amp-替换（Finding-amp-Replacing）"><a href="#查找-amp-替换（Finding-amp-Replacing）" class="headerlink" title="查找&amp;替换（Finding&amp;Replacing）"></a>查找&amp;替换（Finding&amp;Replacing）</h4><ul>
<li>Ctrl + F/H：进行标准查找/替换，之后：<ul>
<li>F3：跳至当前关键字下一个位置</li>
<li>Shift + F3：跳到当前关键字上一个位置</li>
<li>Alt + F3：选中当前关键字出现的所有位置</li>
<li>Alt + C：切换大小写敏感（Case-sensitive）模式</li>
<li>Alt + W：切换整字匹配（Whole matching）模式</li>
<li>Alt + R：切换正则匹配（Regex matching）模式</li>
<li>Ctrl + Shift + H：替换当前关键字</li>
<li>Ctrl + Alt + Enter：替换所有关键字匹配</li>
</ul>
</li>
<li>Ctrl + Shift + F：多文件搜索&amp;替换</li>
</ul>
<p>在搜索框输入关键字后 Enter 跳至关键字当前光标的下一个位置，Shift + Enter 跳至上一个位置，Alt + Enter 选中其出现的所有位置（同样的，接下来可以进行快速替换）。</p>
<p>使用 Ctrl + H 进行标准替换，输入替换内容后，使用 Ctrl + Shift + H 替换当前关键字，Ctrl + Alt + Enter 替换所有匹配关键字。</p>
<h4 id="跳转（Jumping）"><a href="#跳转（Jumping）" class="headerlink" title="跳转（Jumping）"></a>跳转（Jumping）</h4><ul>
<li>Ctrl + P：跳转到指定文件，输入文件名后可以：<ul>
<li>@ 符号跳转：输入@symbol跳转到symbol符号所在的位置</li>
<li># 关键字跳转：输入#keyword跳转到keyword所在的位置</li>
<li>: 行号跳转：输入:12跳转到文件的第12行。</li>
</ul>
</li>
<li>Ctrl + R：跳转到指定符号</li>
<li>Ctrl + G：跳转到指定行号</li>
</ul>
<h4 id="窗口（Window）"><a href="#窗口（Window）" class="headerlink" title="窗口（Window）"></a>窗口（Window）</h4><ul>
<li>Ctrl + Shift + N：创建一个新窗口</li>
<li>Ctrl + N：在当前窗口创建一个新标签</li>
<li>Ctrl + W：关闭当前标签，当窗口内没有标签时会关闭该窗口</li>
<li>Ctrl + Shift + T：恢复刚刚关闭的标签</li>
</ul>
<h4 id="屏幕（Screen）"><a href="#屏幕（Screen）" class="headerlink" title="屏幕（Screen）"></a>屏幕（Screen）</h4><ul>
<li>F11：切换普通全屏</li>
<li>Shift + F11：切换无干扰全屏</li>
<li>Alt + Shift + 2：进行左右分屏</li>
<li>Alt + Shift + 8：进行上下分屏</li>
<li>Alt + Shift + 5：进行上下左右分屏</li>
<li>分屏之后，使用Ctrl + 数字键跳转到指定屏，使用Ctrl + Shift + 数字键将当前屏移动到指定屏</li>
</ul>
<p>作者：常大鹏</p>
<p>链接：<a href="https://www.jianshu.com/p/aab80e642960" target="_blank" rel="noopener">https://www.jianshu.com/p/aab80e642960</a></p>
<p>來源：简书</p>
]]></content>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>VuePress</title>
    <url>/2020/08/06/VuePress/</url>
    <content><![CDATA[<h2 id="VuePress"><a href="#VuePress" class="headerlink" title="VuePress"></a>VuePress</h2><p>轻量级文档服务器，可以用做博客和技术文档，可以部署在Github</p>
<h3 id="VuePress优点"><a href="#VuePress优点" class="headerlink" title="VuePress优点"></a>VuePress优点</h3><ol>
<li>界面简洁优雅</li>
<li>支持Markdown语法</li>
<li>渲染静态HTML，性能优异</li>
</ol>
<h3 id="远程安装VuePress"><a href="#远程安装VuePress" class="headerlink" title="远程安装VuePress"></a>远程安装VuePress</h3><ol>
<li>设置安全组</li>
</ol>
<ul>
<li>登录到阿里云服务器</li>
<li>进入控制台，选择ecs</li>
<li>选择网络与安全</li>
<li>选择安全组，选择实例，进去</li>
<li>在入方向选择手动创建</li>
<li>协议选择自定义TCP，端口范围为22/22和8080/8080，授权对象0.0.0.0/0，保存</li>
<li>退出到实例与镜像里，选择实例，查看公网ip</li>
<li>可以使用XSHELL，远程连接公网ip，输入账号密码测试连接</li>
</ul>
<ol start="2">
<li>安装node.js（官方那个太麻烦了，顶不住，顶不住）</li>
</ol>
<ul>
<li>在官方网站查询你需要的node的版本资源<code>https://github.com/nodesource/distributions</code></li>
<li>给系统添加你需要安装的node资源<code>curl -sL https://rpm.nodesource.com/setup_10.x | bash -</code></li>
<li>安装ndoe.js<code>yum install -y nodejs</code></li>
<li>输入<code>node -v</code>和<code>npm -v</code>查看是否已经安装上了，以及版本是否正确</li>
</ul>
<ol start="3">
<li>安装VuePress</li>
</ol>
<ul>
<li>配置node.js的镜像（国内访问国外太慢了，依旧顶不住）<code>npm config set registry &quot; https://registry.npm.taobao.org &quot;</code></li>
<li>输入<code>npm config get registry</code>查看是否配置成功</li>
<li>安装yarn包管理器<code>npm install -g yarn</code>（官方有俩种安装VuePress的方法，yarn的方法比npm直接安装的速度快）</li>
<li>通过yarn安装VuePress<code>npm install yarn -g</code></li>
<li>这个时候出现错误，可能是node版本太低了，升级一下node版本<code>n stable</code>（升级好慢啊）</li>
<li>重新安装</li>
<li>输入<code>VuePress -v</code>查看是否安装成功</li>
</ul>
<p><strong>VuePress目录结构</strong></p>
<p><img src="https://pic.oldzhg.com/uPic/ibSXcC.png" alt=""></p>
<h3 id="配置VuePress"><a href="#配置VuePress" class="headerlink" title="配置VuePress"></a>配置VuePress</h3><ol>
<li>创建一个文件夹，名字为VuePress<code>mkdir vuepress</code>，进入到文件夹内部<code>cd vuepress</code></li>
<li>然后创建package.json文件夹<code>npm init -y</code>，这个时候会创建出package.json文件，可以ls查看一下</li>
<li>修改package.json文件<code>vi package.json</code></li>
<li>修改成这样</li>
</ol>
<p>保存，退出</p>
<ol start="5">
<li>接着创建文件夹 docs <code>mkdir docs</code></li>
<li>进入到内部<code>cd docs</code></li>
<li>创建文件<code>echo &#39;# Hello VuePress - first blog!&#39; &gt;README.md</code>文件夹<code>mkdir .vuepress</code>进入到文件夹里</li>
<li>创建文件夹和配置文件<code>mkdir public</code>和<code>echo &gt; config.js</code></li>
<li>回到最初的目录<code>cd ../../</code></li>
<li>然后启动vuepress<code>vuepress dev docs</code></li>
<li>打开浏览器输入服务器公网ip及端口号8080，即可看见刚刚写入的hello  VuePress</li>
</ol>
<h3 id="个性化定制"><a href="#个性化定制" class="headerlink" title="个性化定制"></a>个性化定制</h3><p>修改README.md⽂件，将原来的内容删除后，将以下内容拷贝进去</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">home:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">heroText:</span> <span class="string">Vue技术博客初试</span></span><br><span class="line"><span class="attr">tagline:</span> <span class="string">项⽬目结构，关注讨论，每⽇日分享</span></span><br><span class="line"><span class="attr">actionText:</span> <span class="string">每⽇日更更新</span> <span class="string">→</span></span><br><span class="line"><span class="attr">actionLink:</span> <span class="string">/testlink/</span></span><br><span class="line"><span class="attr">features:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">title:</span> <span class="string">项⽬目结构</span></span><br><span class="line"><span class="attr">details:</span> <span class="string">以</span> <span class="string">Markdown</span> <span class="string">为中⼼心的项⽬目结构，以最少的配置帮助你专注于写作。</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">title:</span> <span class="string">关注讨论</span></span><br><span class="line"><span class="attr">details:</span> <span class="string">享受</span> <span class="string">Vue</span> <span class="string">+</span> <span class="string">webpack</span> <span class="string">的开发体验，在</span> <span class="string">Markdown</span> <span class="string">中使⽤用</span> <span class="string">Vue</span> <span class="string">组件，同</span></span><br><span class="line"><span class="string">时可以使⽤用</span> <span class="string">Vue</span> <span class="string">来开发⾃自定义主题。</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">title:</span> <span class="string">每⽇日分享</span></span><br><span class="line"><span class="attr">details:</span> <span class="string">VuePress</span> <span class="string">为每个⻚页⾯面预渲染⽣生成静态的</span> <span class="string">HTML，同时在⻚页⾯面被加载的</span></span><br><span class="line"><span class="string">时候，将作为</span> <span class="string">SPA</span> <span class="string">运⾏行行。</span></span><br><span class="line"><span class="attr">footer:</span> <span class="string">LearnVueonECS</span> <span class="string">Licensed</span> <span class="string">|</span> <span class="string">Copyright</span> <span class="string">©</span> <span class="number">2020</span><span class="string">-present</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>

<p>演示效果如下</p>
<p><img src="https://oss.oldzhg.com/uPic/image-20200806201815666.png" alt="image-20200806201815666"></p>
<p>你也可以自己继续换主题，定制插件让样式更多样，在官网上就有介绍<a href="https://www.vuepress.cn/" target="_blank" rel="noopener">VuePress官网</a></p>
]]></content>
      <categories>
        <category>ECS七天训练营</category>
      </categories>
  </entry>
  <entry>
    <title>Mac 微信备份到外接硬盘方案</title>
    <url>/2022/10/08/WeChat-backs-up-to-an-external-hard-disk-on-Mac/</url>
    <content><![CDATA[<hr>
<blockquote>
<p>mac版本微信中并没有指定备份路径的功能，备份的聊天记录文件也在一个很难找的位置。对于使用256g硬盘的mac的用户，微信聊天记录动辄十几G、几十G的大小，会造成非常严重的硬盘容量恐慌。所以把微信备份文件迁移到外置硬盘是一件非常有意义的工作。</p>
</blockquote>
<h2 id="微信的备份路径"><a href="#微信的备份路径" class="headerlink" title="微信的备份路径"></a>微信的备份路径</h2><p>微信的备份在</p>
<p><code>~/Library/Containers/com.tencent.xinWeChat/Data/Library/Application\ Support/com.tencent.xinWeChat/2.0b4.0.9</code> 这个目录下面的 <code>Backup</code> 文件夹里面。</p>
<p><img src="https://pic.oldzhg.com/uPic/image-1663224431683.webp" alt="image-1663224431683"></p>
<p>每一个微信账号的聊天记录备份对应这个目录下的一个文件夹（名称为一长串的字母及数字)</p>
<h2 id="比较简单的迁移方式"><a href="#比较简单的迁移方式" class="headerlink" title="比较简单的迁移方式"></a>比较简单的迁移方式</h2><p>知道了文件备份在那个目录，其实我们只需要每次备份完成之后，把这个里面的文件夹剪切粘贴到移动硬盘的指定位置即可。<br>需要恢复备份的时候再从移动硬盘里面把文件拷贝回这个目录即可。</p>
<h2 id="更智能的迁移方式"><a href="#更智能的迁移方式" class="headerlink" title="更智能的迁移方式"></a>更智能的迁移方式</h2><p>前一种方式操作起来稍微有点麻烦，需要自己来回复制，怎么才能省略掉这两个手动复制粘贴的操作呢，答案就是使用软连接的方式。</p>
<ul>
<li>如果你的mac版微信没有执行过备份操作，那可能没有这个Backup目录，或者Backup目录下面没有子目录，为了保证文件权限一致，需要先执行一次备份生成这个目录（无需全量备份，只备份一个人的聊天记录都行）</li>
<li>备份完成之后，将该 <code>Backup</code> 目录复制到移动硬盘下的某个目录，比如 <code>/Volumes/硬盘名/backup/wechat</code></li>
<li>复制完成之后就可以把微信默认备份路径下的 <code>Backup</code> 目录删除了，当然你不放心的话，也可以删除前先备份一下。</li>
<li>然后创建软连接，打开终端，执行如下命令。（注意。此处的 <code>硬盘名</code> 要改成你自己的外置硬盘的盘符名称）</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ln -s /Volumes/硬盘名/backup/wechat/Backup ~/Library/Containers/com.tencent.xinWeChat/Data/Library/Application\ Support/com.tencent.xinWeChat/2.0b4.0.9/Backup</span><br></pre></td></tr></table></figure>

<ul>
<li><p>此时就能看到软连接已经创建好了，微信目录下的Backup已经指向到了移动硬盘下的Backup目录</p>
<p><img src="https://pic.oldzhg.com/uPic/image-1663225770604.webp" alt="image-1663225770604"></p>
</li>
<li><p>第一步的时候我们已经备份了一次，此时进入微信的备份设置那里进入<code>管理备份文件</code>栏目之后，按道理是能看到一个备份的，但是实际上却毛都没有，这又是闹哪样呢</p>
</li>
<li><p>因为mac下的应用是以沙盒模式运行，无法直接读取不在该应用程序目录以外的目录，所以虽然创建软连接把备份目录指向外置硬盘了，但实际上还是读取不到的。要解决这个问题需要先退出微信，然后重新签名微信，再执行如下代码即可给微信重新签名。</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo codesign --sign - --force --deep /Applications/WeChat.app</span><br></pre></td></tr></table></figure>

<ul>
<li><p>重签之后再打开微信，再次进入<code>管理备份文件</code> 栏目,会弹出一个是否允许访问外挂硬盘的提示，点击同意之后就能看到我们之前的备份了</p>
<div align=center><img src="https://pic.oldzhg.com/uPic/image-1663226325395.webp" alt="image-1663226325395" style="zoom:50%;" /></div>



</li>
</ul>
<h2 id="话外"><a href="#话外" class="headerlink" title="话外"></a>话外</h2><ul>
<li>软链接的方式更方便，只要硬盘插着的，你执行备份、恢复的操作都会直接走移动硬盘，相当于直接正常操作就会把文件备份到移动硬盘里面。既不占用电脑存储空间，又不需要额外操作。</li>
<li>很早之前我就用过创建软连接的方式来备份微信聊天记录到外置存储，那时候直接创建软连接就完事了，创建完就能正常读取恢复， 但是后面不知道什么时候开始就出问题了，软连接还在，但是备份恢复都不好使了，完全读取不到了。尝试过很多办法都没解决，最终搜到了 <a href="https://blog.zcw159357.com/article/1/2021-07-20-0033.html" target="_blank" rel="noopener">这篇博客</a> 才终于发现了解决方案，非常感谢这个博主。</li>
<li>经过博主测试，备份、恢复、插拔硬盘之后再操作、重启微信之后再操作均正常，但是还没试过更新微信之后是什么效果，不过目测更新微信版本之后应该会失效，不过解决方法也很简单，重新执行签名命令签名一次就行。</li>
</ul>
<h3 id="转自：https-luoxx-top-archives-mac-wechat-backup-path"><a href="#转自：https-luoxx-top-archives-mac-wechat-backup-path" class="headerlink" title="转自：https://luoxx.top/archives/mac-wechat-backup-path"></a>转自：<a href="https://luoxx.top/archives/mac-wechat-backup-path" target="_blank" rel="noopener">https://luoxx.top/archives/mac-wechat-backup-path</a></h3>]]></content>
      <categories>
        <category>工具技巧</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows7 PowerShell 2.0升级到 PowerShell 5.1</title>
    <url>/2020/03/05/Windows7%20PowerShell%202.0%20upgrade%20to%20PowerShell%205.1/</url>
    <content><![CDATA[<p>两种方案可以查询：</p>
<ul>
<li><p><a href="https://docs.microsoft.com/en-us/skypeforbusiness/set-up-your-computer-for-windows-powershell/download-and-install-windows-powershell-5-1" target="_blank" rel="noopener">官方链接</a></p>
</li>
<li><p><a href="https://blog.csdn.net/xiayuexingkong/article/details/93733047" target="_blank" rel="noopener">CSDN</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>Tech</tag>
      </tags>
  </entry>
  <entry>
    <title>基于ECS构建微信公众号管理系统</title>
    <url>/2020/08/08/WeEngine/</url>
    <content><![CDATA[<h3 id="下载解压"><a href="#下载解压" class="headerlink" title="下载解压"></a>下载解压</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://cdn.w7.cc/download/WeEngine-Laster-Online.zip</span><br><span class="line">unzip -d wechat WeEngine-Laster-Online.zip</span><br></pre></td></tr></table></figure>

<p>修改nginx默认目录到wechat,重启nginx</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure>

<h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p</span><br><span class="line">create database wechat;</span><br><span class="line">show databases;</span><br></pre></td></tr></table></figure>

<img src="https://oss.oldzhg.com/uPic/image-20200808202241760.png" alt="image-20200808202241760" style="zoom:50%;" />

<h3 id="开始部署"><a href="#开始部署" class="headerlink" title="开始部署"></a>开始部署</h3><p>打开网站，<code>http://ip/install.php</code></p>
<img src="https://pic.oldzhg.com/uPic/Xnip2020-08-08_20-18-00.jpg" alt="Xnip2020-08-08_20-18-00" style="zoom:50%;" />

<p>发现目录权限不足，授予刚刚创建的wechat目录权限即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chown -R www &#x2F;data&#x2F;wwwroot&#x2F;wechat</span><br></pre></td></tr></table></figure>

<p>继续安装</p>
<img src="https://pic.oldzhg.com/uPic/image-20200808202633209.png" alt="image-20200808202633209" style="zoom:50%;" />

<p>到这里就基本完成系统的部署</p>
<h3 id="添加公众号"><a href="#添加公众号" class="headerlink" title="添加公众号"></a>添加公众号</h3><p>剩下就是微信公众号的添加，不再赘述</p>
<p>完成大概这个样子</p>
<img src="https://pic.oldzhg.com/uPic/image-20200808205941459.png" alt="image-20200808205941459" style="zoom:50%;" />


]]></content>
      <categories>
        <category>ECS七天训练营</category>
      </categories>
  </entry>
  <entry>
    <title>virmach 上搭建 ss + bbr</title>
    <url>/2017/12/22/build-ss/</url>
    <content><![CDATA[<h4 id="购买"><a href="#购买" class="headerlink" title="购买"></a>购买</h4><p>前段时间一直在寻找一台便宜够用的VPS单单作FQ用，偶然间看到virmach打75折，于是入了一台年付仅9.37（约合人民币61.98元)。优惠码：zhujiceping25<br><img src="//pic.oldzhg.com/uPic/price.png" alt=""></p>
<h4 id="安装bbr加速"><a href="#安装bbr加速" class="headerlink" title="安装bbr加速"></a>安装bbr加速</h4><p>输入命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh</span><br><span class="line">chmod +x bbr.sh</span><br><span class="line">./bbr.sh</span><br></pre></td></tr></table></figure>
<p>安装完毕并重启, 执行如下命令： </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsmod | grep bbr</span><br></pre></td></tr></table></figure>
<p>返回值有tcp-bbr模块即说明bbr已启动。<br><img src="//pic.oldzhg.com/uPic/bbr.png" alt=""></p>
<h4 id="使用Superspeed脚本测速"><a href="#使用Superspeed脚本测速" class="headerlink" title="使用Superspeed脚本测速"></a>使用Superspeed脚本测速</h4><p>脚本如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install wget</span><br><span class="line">wget -qO- https://raw.githubusercontent.com/wn789/Superspeed/master/superbench.sh | bash</span><br></pre></td></tr></table></figure>
<p>如下图所示，速度还是很快的，果然是G口。<br><img src="//pic.oldzhg.com/uPic/test1.png" alt=""></p>
<h4 id="安装Shadowsocks"><a href="#安装Shadowsocks" class="headerlink" title="安装Shadowsocks"></a>安装Shadowsocks</h4><p>运行脚本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.sh</span><br><span class="line">chmod +x shadowsocks-all.sh</span><br><span class="line">./shadowsocks-all.sh 2&gt;&amp;1 | tee shadowsocks-all.log</span><br></pre></td></tr></table></figure>
<p>依次选择安装版本、ss密码、端口、加密方式后如图，<br><img src="//pic.oldzhg.com/uPic/build_ss.png" alt=""><br>等待安装完成，<br><img src="//pic.oldzhg.com/uPic/complete.png" alt=""><br>测试可用，接下来将配置文件修改为多用户多端口，执行命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /etc/shadowsocks-python/config.json</span><br></pre></td></tr></table></figure>
<p>下面是文件示例：<br><img src="//pic.oldzhg.com/uPic/example.png" alt=""><br>修改后重启shadowsocks</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/etc/init.d/shadowsocks-python restart</span><br></pre></td></tr></table></figure>
<h4 id="本地测试"><a href="#本地测试" class="headerlink" title="本地测试"></a>本地测试</h4><p>本地20M宽带测试速度表现很好<br><img src="//pic.oldzhg.com/uPic/test2.png" alt=""></p>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ol>
<li>Shadowsocks 一键安装脚本（四合一）<br> <a href="https://shadowsocks.be/11.html" target="_blank" rel="noopener">https://shadowsocks.be/11.html</a></li>
<li>VPS网络优化各种方法汇总——锐速/BBR/BBR魔改版一键安装脚本<br> <a href="https://www.cokemine.com/vpsyh.html" target="_blank" rel="noopener">https://www.cokemine.com/vpsyh.html</a></li>
<li>Superspeed一键测速脚本<br> <a href="https://www.wn789.com/9504.html" target="_blank" rel="noopener">https://www.wn789.com/9504.html</a></li>
<li>Shadowsocks Python版一键安装脚本<br> <a href="https://shadowsocks.be/1.html" target="_blank" rel="noopener">https://shadowsocks.be/1.html</a></li>
</ol>
]]></content>
      <tags>
        <tag>Tech</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客在文章中插入图片</title>
    <url>/2017/12/23/insert_image_in_hexo/</url>
    <content><![CDATA[<p>在写文章时，常常有配图说明的需求。Hexo有多种图片插入方式，可以将图片存放在本地引用或者将图片放在CDN上引用。</p>
<h3 id="绝对路径"><a href="#绝对路径" class="headerlink" title="绝对路径"></a>绝对路径</h3><p>当Hexo项目中只用到少量图片时，可以将图片统一放在source/images文件夹中，通过markdown语法访问它们。</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line">!<span class="selector-attr">[]</span>(/images/image.jpg)</span><br></pre></td></tr></table></figure>
<p>图片既可以在首页内容中访问到，也可以在文章正文中访问到。</p>
<h3 id="相对路径"><a href="#相对路径" class="headerlink" title="相对路径"></a>相对路径</h3><p>图片除了可以放在统一的images文件夹中，还可以放在文章自己的目录中。文章的目录可以通过配置_config.yml来生成。</p>
<p>将_config.yml文件中的配置项post_asset_folder设为true后，执行命令$ hexo new post_name，在source/_posts中会生成文章post_name.md和同名文件夹post_name。将图片资源放在post_name中，文章就可以使用相对路径引用图片资源了。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">!<span class="selector-attr">[]</span>(<span class="selector-tag">image</span><span class="selector-class">.jpg</span>)</span><br></pre></td></tr></table></figure>
<p>上述是markdown的引用方式，图片只能在文章中显示，但无法在首页中正常显示。</p>
<h3 id="标签插件语法"><a href="#标签插件语法" class="headerlink" title="标签插件语法"></a>标签插件语法</h3><p>如果希望图片在文章和首页中同时显示，可以使用标签插件语法。</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">&#123;<span class="symbol">%</span> asset_img <span class="built_in">image</span>.jpg This <span class="built_in">is</span> an <span class="built_in">image</span> <span class="symbol">%</span>&#125;</span><br></pre></td></tr></table></figure>


<p>转自：<a href="https://yanyinhong.github.io/2017/05/02/How-to-insert-image-in-hexo-post/" target="_blank" rel="noopener">https://yanyinhong.github.io/2017/05/02/How-to-insert-image-in-hexo-post/</a></p>
]]></content>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>macOS安装tensor flow 基于 Anaconda 的安装</title>
    <url>/2019/12/09/macOS%E5%AE%89%E8%A3%85tensor%20flow%20%E5%9F%BA%E4%BA%8E%20Anaconda%20%E7%9A%84%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="1-安装Anaconda"><a href="#1-安装Anaconda" class="headerlink" title="1.安装Anaconda"></a>1.安装Anaconda</h2><p><a href="https://www.anaconda.com/distribution/#macos" target="_blank" rel="noopener">下载地址</a></p>
<p>下载完后命令行无法识别conda</p>
<p>原因是环境变量没有配置好，终端输入</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">vi ~<span class="string">/.bash_profile</span></span><br></pre></td></tr></table></figure>

<p>然后如果没有的话就在环境变量里加一句：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="builtin-name">export</span> <span class="attribute">PATH</span>=<span class="string">"/Users/Mac/anaconda3/bin:<span class="variable">$PATH</span>"</span></span><br></pre></td></tr></table></figure>

<p>source ~/.bash_profile### ，刷新环境变量</p>
<h2 id="2-建立一个叫tensorflow的conda计算环境"><a href="#2-建立一个叫tensorflow的conda计算环境" class="headerlink" title="2.建立一个叫tensorflow的conda计算环境"></a>2.建立一个叫tensorflow的conda计算环境</h2><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">conda create -n tensorflow <span class="attribute">python</span>=3.6</span><br></pre></td></tr></table></figure>

<h2 id="3-激活tensorflow环境"><a href="#3-激活tensorflow环境" class="headerlink" title="3.激活tensorflow环境"></a>3.激活tensorflow环境</h2><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">source <span class="built_in">activate</span> tensorflow</span><br></pre></td></tr></table></figure>

<h2 id="4-在该环境中安装tensorflow"><a href="#4-在该环境中安装tensorflow" class="headerlink" title="4.在该环境中安装tensorflow"></a>4.在该环境中安装tensorflow</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">conda <span class="keyword">install</span> tensorflow</span><br></pre></td></tr></table></figure>

<h2 id="5-关闭conda环境"><a href="#5-关闭conda环境" class="headerlink" title="5.关闭conda环境"></a>5.关闭conda环境</h2><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">anado deactivate</span></span><br></pre></td></tr></table></figure>
<h3 id="要使用tensorflow的时候激活环境即可"><a href="#要使用tensorflow的时候激活环境即可" class="headerlink" title="要使用tensorflow的时候激活环境即可"></a>要使用tensorflow的时候激活环境即可</h3><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">source <span class="built_in">activate</span> tensorflow</span><br></pre></td></tr></table></figure>
<h2 id="6-测试代码"><a href="#6-测试代码" class="headerlink" title="6.测试代码"></a>6.测试代码</h2><p>忽略警告</p>
<figure class="highlight moonscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="built_in">os</span> </span><br><span class="line"><span class="built_in">os</span>.environ[<span class="string">'TF_CPP_MIN_LOG_LEVEL'</span>] = <span class="string">'2'</span></span><br></pre></td></tr></table></figure>

<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">/<span class="comment">#查看tensorflow版本/</span></span><br><span class="line"><span class="built_in">print</span>(tf.__version__)</span><br></pre></td></tr></table></figure>

<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">import tensorflow as tf</span><br><span class="line"></span><br><span class="line">tf<span class="selector-class">.compat</span><span class="selector-class">.v1</span>.disable_eager_execution()</span><br><span class="line"></span><br><span class="line">hello = tf.constant(<span class="string">'Hello, TensorFlow!'</span>)</span><br><span class="line"></span><br><span class="line">sess = tf<span class="selector-class">.compat</span><span class="selector-class">.v1</span>.Session()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(sess.run(hello)</span></span>)</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>VPS上安装rclone实现挂载谷歌云盘</title>
    <url>/2020/03/15/rclone-use/</url>
    <content><![CDATA[<h2 id="rclone安装"><a href="#rclone安装" class="headerlink" title="rclone安装"></a>rclone安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl https://rclone.org/install.sh | bash</span><br><span class="line"></span><br><span class="line">rclone config</span><br><span class="line"></span><br><span class="line"><span class="comment">#新建本地文件夹，路径自己定，即下面的LocalFolder</span></span><br><span class="line">mkdir /root/GoogleDrive</span><br><span class="line"><span class="comment">#挂载为磁盘，下面的DriveName、Folder、LocalFolder参数根据说明自行替换</span></span><br><span class="line">rclone mount DriveName:Folder LocalFolder --copy-links --no-gzip-encoding --no-check-certificate --allow-other --allow-non-empty --<span class="built_in">umask</span> 000 &amp;</span><br><span class="line"></span><br><span class="line">rclone mount Kid:/ /data/wwwroot/directory/GoogleDrive --copy-links --no-gzip-encoding --no-check-certificate --allow-other --allow-non-empty --<span class="built_in">umask</span> 000 &amp;</span><br><span class="line"></span><br><span class="line"><span class="comment">#卸载</span></span><br><span class="line">fusermount -qzu LocalFolder</span><br></pre></td></tr></table></figure>

<h2 id="开启自启动"><a href="#开启自启动" class="headerlink" title="开启自启动"></a>开启自启动</h2><p>先新建<code>systemd</code>配置文件，适用<code>CentOS 7</code>、<code>Debian 8+</code>、<code>Ubuntu 16+</code>。</p>
<p>再使用命令：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment">#将后面修改成你上面手动运行命令中，除了rclone的全部参数</span></span><br><span class="line"><span class="attribute">command</span>=<span class="string">"mount DriveName:Folder LocalFolder --copy-links --no-gzip-encoding --no-check-certificate --allow-other --allow-non-empty --umask 000"</span></span><br><span class="line"><span class="comment">#以下是一整条命令，一起复制到SSH客户端运行</span></span><br><span class="line">cat &gt; /etc/systemd/system/rclone.service &lt;&lt;EOF</span><br><span class="line">[Unit]</span><br><span class="line"><span class="attribute">Description</span>=Rclone</span><br><span class="line"><span class="attribute">After</span>=network-online.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line"><span class="attribute">Type</span>=simple</span><br><span class="line"><span class="attribute">ExecStart</span>=$(command -v rclone) <span class="variable">$&#123;command&#125;</span></span><br><span class="line"><span class="attribute">Restart</span>=on-abort</span><br><span class="line"><span class="attribute">User</span>=root</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line"><span class="attribute">WantedBy</span>=default.target</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<p>开始启动：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">systemctl <span class="literal">start</span> rclone</span><br></pre></td></tr></table></figure>

<p>设置开机自启：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">systemctl <span class="builtin-name">enable</span> rclone</span><br></pre></td></tr></table></figure>

<p>其他命令：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">重启：systemctl restart rclone</span><br><span class="line">停止：systemctl <span class="keyword">stop</span> rclone</span><br><span class="line">状态：systemctl <span class="keyword">status</span> rclone</span><br></pre></td></tr></table></figure>

<p>如果你想挂载多个网盘，那么将<code>systemd</code>配置文件的<code>rclone.service</code>改成<code>rclone1.service</code>即可，重启动什么的同样换成<code>rclone1</code>。</p>
<h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><ul>
<li>别把挂载盘当下载目录，可以下载到其它目录后，移动进挂载盘</li>
</ul>
]]></content>
      <tags>
        <tag>Tech</tag>
      </tags>
  </entry>
  <entry>
    <title>保持ssh不自动断开</title>
    <url>/2020/03/09/prevent-ssh-auto-disconnect/</url>
    <content><![CDATA[<p>在mac上ssh自己的服务器后总是会断开，比如wget某一个东西，或者tar一个大文件，如果你总是受此困扰，不妨尝试一下此文里的配置。</p>
<p>其实ssh已经考虑到了此问题，但是可能考虑到安全和资源占用等因素，默认没有启用，现在我们把它打开。</p>
<h2 id="服务端设置"><a href="#服务端设置" class="headerlink" title="服务端设置"></a>服务端设置</h2><p>找到<code>/etc/ssh/sshd_config</code>，大约126-127行，取消注释，并修改数值</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"># <span class="number">30</span>表示<span class="number">30</span>s给客户端发送一次心跳</span><br><span class="line">ClientAliveInterval <span class="number">30</span></span><br><span class="line"># <span class="number">3</span>此客户端没有返回心跳，则会断开连接</span><br><span class="line">ClientAliveCountMax <span class="number">3</span></span><br></pre></td></tr></table></figure>

<h2 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h2><p>如果是想让主机所有用户都生效，修改<code>/etc/ssh/ssh_config</code><br>如果只想让本人生效，则修改 <code>~/.ssh/config</code></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">Host</span> <span class="string">*</span></span><br><span class="line">    <span class="attr">ServerAliveInterval</span> <span class="string">30</span></span><br><span class="line">    <span class="attr">ServerAliveCountMax</span> <span class="string">3</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果此处还有一个配置项叫 SendEnv LANG LC_*，老高建议最好注释掉，否则如果本地是中文环境，而服务器没有对应的中文语言选项时系统可能会出现很多莫名其妙的BUG，所以保持原始英文语言环境为上。</p>
</blockquote>
<h2 id="一次性配置"><a href="#一次性配置" class="headerlink" title="一次性配置"></a>一次性配置</h2><p>如果只是想临时使用一次，完全可以不用大动干戈地找配置文件改，ssh命令支持直接注入参数，如下：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">ssh -o ServerAliveInterval=<span class="number">30</span> <span class="symbol">user@</span>host</span><br></pre></td></tr></table></figure>

<h2 id="查看是否生效"><a href="#查看是否生效" class="headerlink" title="查看是否生效"></a>查看是否生效</h2><p>想测试是否生效，我们直接ssh到服务器后等一会儿看效果就行，但是如果想看到服务器和客户端发送心跳包的过程，可以这样</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">ssh -o ServerAliveInterval=<span class="number">30</span> -vvv <span class="symbol">user@</span>host</span><br></pre></td></tr></table></figure>

<p>等30s后我们应该可以看到如下字样，说明我们在指定时间发送了心跳给服务器，服务器也有应答。同理如果我们在服务器也打开了心跳，则应该是先收到服务器的心跳然后再应答。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">debug3: send packet:<span class="built_in"> type </span>80</span><br><span class="line">debug3: receive packet:<span class="built_in"> type </span>82</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://bluebiu.com/blog/linux-ssh-session-alive.html" target="_blank" rel="noopener">Linux使用ssh超时断开连接的真正原因</a></p>
]]></content>
      <tags>
        <tag>Tech</tag>
      </tags>
  </entry>
  <entry>
    <title>Vimuim的一些常用快捷键</title>
    <url>/2017/10/05/vimuim/</url>
    <content><![CDATA[<h2 id="常用"><a href="#常用" class="headerlink" title="常用"></a><strong>常用</strong></h2><ul>
<li>J ，gT 上一个标签</li>
<li>K ，gt 下一个标签</li>
<li>k 向上滚动</li>
<li>j 向下滚动 </li>
<li>gg 回到页面最顶端</li>
<li>G 回到页面最底部</li>
<li>d 向上翻屏</li>
<li>u 向下翻屏</li>
<li>复制链接后，小写p在当前页面打开，* 大写P在新标签页打开</li>
<li>o查找书签，历史</li>
</ul>
<ul>
<li><p>f 显示当前可点击所有超链接</p>
</li>
<li><p>t 创建一个新的标签页</p>
</li>
<li><p>T 查看当前所有标签页</p>
</li>
<li><p>h 向左移动</p>
</li>
<li><p>l 向右移动</p>
</li>
<li><p>zH 最左  zL最右</p>
</li>
<li><p>？ 显示帮助</p>
</li>
<li><p>/ 查找 输入文字后enter n 向下查找</p>
</li>
<li><p>F6 当前标签页输入新网址 同ctrl+l</p>
</li>
<li><p>r 刷新</p>
</li>
<li><p>x 关闭当前页面</p>
</li>
<li><p>X 恢复刚刚关闭的页面</p>
</li>
<li><p>O 在新窗口打开  网页，历史，书签</p>
</li>
<li><p>v 还在学习</p>
</li>
</ul>
<h2 id="非常用"><a href="#非常用" class="headerlink" title="非常用"></a><strong>非常用</strong></h2><ul>
<li>gs 查看页面源代码</li>
<li>yy 拷贝当前页面url</li>
<li>i 输入模式，屏蔽一切命令，esc以取消</li>
<li>f 在当前页面打开一个新的链接</li>
<li>F 在新的页面的开一个新的链接</li>
<li>b 在当前页面打开一个书签</li>
<li>gf 循环到当前页面的下一个框层</li>
</ul>
]]></content>
      <tags>
        <tag>Tech</tag>
      </tags>
  </entry>
  <entry>
    <title>把Aria2做成服务</title>
    <url>/2018/11/24/%E6%8A%8AAria2%E5%81%9A%E6%88%90%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<p>添加开机启动：</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">vi <span class="meta-keyword">/etc/</span>init.d/aria2c    <span class="meta">#把Aria2做成服务</span></span><br></pre></td></tr></table></figure>

<p>粘贴以下代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment">### BEGIN INIT INFO</span></span><br><span class="line"><span class="comment"># Provides: aria2</span></span><br><span class="line"><span class="comment"># Required-Start: $remote_fs $network</span></span><br><span class="line"><span class="comment"># Required-Stop: $remote_fs $network</span></span><br><span class="line"><span class="comment"># Default-Start: 2 3 4 5</span></span><br><span class="line"><span class="comment"># Default-Stop: 0 1 6</span></span><br><span class="line"><span class="comment"># Short-Description: Aria2 Downloader</span></span><br><span class="line"><span class="comment">### END INIT INFO</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">case</span> <span class="string">"<span class="variable">$1</span>"</span> <span class="keyword">in</span></span><br><span class="line">start)</span><br><span class="line"> </span><br><span class="line"> <span class="built_in">echo</span> -n <span class="string">"已开启Aria2c"</span></span><br><span class="line"> sudo -u root aria2c --conf-path=/data/wwwroot/download/aria2.conf -D</span><br><span class="line"> <span class="comment">#sudo -u后面的是你正在使用的用户名</span></span><br><span class="line">;;</span><br><span class="line">stop)</span><br><span class="line"> </span><br><span class="line"> <span class="built_in">echo</span> -n <span class="string">"已关闭Aria2c"</span></span><br><span class="line"> killall aria2c</span><br><span class="line">;;</span><br><span class="line">restart)</span><br><span class="line"> </span><br><span class="line"> killall aria2c</span><br><span class="line"> sudo -u root aria2c --conf-path=/data/wwwroot/download/aria2.conf -D</span><br><span class="line"> <span class="comment">#同上面的一样，根据自己的用户改-u后面的用户名</span></span><br><span class="line">;;</span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure>

<p>保存文件把权限给为755：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">chmod <span class="number">755</span> /etc/init.d/aria2c</span><br></pre></td></tr></table></figure>

<p>保存文件把权限给为755：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">service aria2c <span class="literal">start</span></span><br></pre></td></tr></table></figure>

<p>测试Aria2服务是否可以正常启动：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">service aria2c <span class="literal">start</span></span><br></pre></td></tr></table></figure>

<p>如果只显示“开启Aria2c”，没有其他错误提示的话就说明成功了。添加Aria2c服务到开机启动：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span>-rc.d aria2c <span class="keyword">defaults</span></span><br></pre></td></tr></table></figure>

<p>Aria2c服务命令使用说明：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">service aria<span class="number">2</span><span class="keyword">c</span> start //启动Aria<span class="number">2</span><span class="keyword">c</span></span><br><span class="line">service aria<span class="number">2</span><span class="keyword">c</span> restart //重启Aria<span class="number">2</span><span class="keyword">c</span></span><br><span class="line">service aria<span class="number">2</span><span class="keyword">c</span> stop /关闭Aria<span class="number">2</span><span class="keyword">c</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Tech</tag>
      </tags>
  </entry>
  <entry>
    <title>windows系统引导的修复</title>
    <url>/2018/01/06/repaire_windows/</url>
    <content><![CDATA[<p>　　最近由于安装黑苹果，经常不经意间就破坏了win10的引导，所以在多次查询相关资料后记录下每次恢复的过程与具体步骤。</p>
<h3 id="UEFI引导基本原理"><a href="#UEFI引导基本原理" class="headerlink" title="UEFI引导基本原理"></a>UEFI引导基本原理</h3><h4 id="1、esp引导分区"><a href="#1、esp引导分区" class="headerlink" title="1、esp引导分区"></a>1、esp引导分区</h4><p> 　　esp磁盘分区是gpt格式硬盘放efi引导文件的磁盘，在mbr格式硬盘中也可以由任一fat格式磁盘分区代替</p>
<h4 id="2、efi文件结构"><a href="#2、efi文件结构" class="headerlink" title="2、efi文件结构"></a>2、efi文件结构</h4><pre><code>　　efi\\boot\\bootx64.efi
　　efi\\microsoft\\boot\\bcd</code></pre><h4 id="3、efi启动过程"><a href="#3、efi启动过程" class="headerlink" title="3、efi启动过程"></a>3、efi启动过程</h4><p>　　uefi bios启动时，自动查找硬盘下esp分区的bootx64.efi，然后由bootx64.efi引导efi下的bcd文件，由bcd引导指定系统文件（一般为c:\windows\system32\winload.efi）</p>
<h3 id="修复方法"><a href="#修复方法" class="headerlink" title="修复方法"></a>修复方法</h3><h4 id="用bootice手动修复"><a href="#用bootice手动修复" class="headerlink" title="用bootice手动修复"></a>用bootice手动修复</h4><p>　　从efi引导启动过程来看，虽然它的文件很多，但主要用到的就是两文件，我们完全可以在各Win　pe下挂载esp分区，从硬盘系统中复制bootx64.efi文件，然后用用bootice制作好bcd，就完成efi引导修复。<br>1、启动任一Win　pe，用esp分区挂载器或diskgenuis挂载esp分区<br>2、查看esp分区是否可正常读写，如不正常可重新格式化为fat16分区格式。<br>3.在esp分区中建立如下空文件夹结构<br>　　\efi\boot\   （bootx64.efi等复制）<br>　　\efi\microsoft\boot\（bcd等建立）<br>4、复制硬盘系统中的bootmgfw.efi（一般在c:\windows\boot\efi下）到esp分区的\efi\boot\下，并重命名为bootx64.efi<br>5、打开bootice软件，有esp分区的\efi\microsoft\boot\下新建立一bcd文件，<br>　打开并编辑bcd文件，添加“windows vista\7\8启动项，指定磁盘为硬盘系统盘在的盘，指定启动分区为硬盘系统分区（一般为c:）<br>　最后保存当前系统设置并退出。</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol>
<li>指定启动分区不是esp分区所在分区，就是硬盘64位Win7、Win8 系统所在分区</li>
<li>指定启动文件为\Windows\system32\winload.efi 是.efi，不是.exe，要手工改过来</li>
</ol>
]]></content>
      <tags>
        <tag>Tech</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>Oneindex搭建</title>
    <url>/2018/05/07/Oneindex_setup/</url>
    <content><![CDATA[<p>前些时间弄到了Onedrive 5T的账号，放着也是闲着，于是用来放点从网络上搜寻来的资源，一是为自己做个备份，二是分享出来大家有需要可以自行取用。</p>
<p>站点：<a href="https://cloud.oldzhg.com" target="_blank" rel="noopener">https://cloud.oldzhg.com</a></p>
]]></content>
      <tags>
        <tag>Tech</tag>
        <tag>杂记</tag>
      </tags>
  </entry>
  <entry>
    <title>使用denyhosts防止ssh暴力破解</title>
    <url>/2020/02/24/%E4%BD%BF%E7%94%A8denyhosts%E9%98%B2%E6%AD%A2ssh%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/</url>
    <content><![CDATA[<p>配合<a href="https://zhuanlan.zhihu.com/p/36404653" target="_blank" rel="noopener">DenyHosts防御ssh暴力破解</a>阅读搭建更快</p>
<p><em>当你的 Linux 服务器暴露在互联网之中,该服务器将会遭到互联网上的扫描软件进行扫描,并试图猜测SSH登录口令。你会发现,每天会有多条SSH登录失败纪录。那些扫描工具将对你的服务器构成威胁,你必须设置复杂登录口令,并将尝试多次登录失败的IP给阻止掉,让其在一段时间内不能访问该服务器。</em></p>
<h2 id="1-denyhosts介绍"><a href="#1-denyhosts介绍" class="headerlink" title="1. denyhosts介绍"></a>1. denyhosts介绍</h2><p><code>denyhosts</code>是<code>Python</code>语言写的一个程序，它会分析<code>sshd</code>的日志文件（<code>/var/log/secure</code>），当发现重 复的攻击时就会记录<code>IP</code>到<code>/etc/hosts.deny</code>文件，从而达到自动屏<code>IP</code>的功能。</p>
<h2 id="2-下载和安装"><a href="#2-下载和安装" class="headerlink" title="2. 下载和安装"></a>2. 下载和安装</h2><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>wget <span class="symbol">https:</span>/<span class="regexp">/nchc.dl.sourceforge.net/project</span><span class="regexp">/denyhosts/denyhosts</span><span class="regexp">/2.6/</span>DenyHosts<span class="number">-2.6</span>.tar.gz  <span class="comment">#下载</span></span><br><span class="line"><span class="variable">$ </span>tar -zxvf DenyHosts<span class="number">-2.6</span>.tar.gz  <span class="comment">#解压</span></span><br><span class="line"><span class="variable">$ </span>cd DenyHosts<span class="number">-2.6</span> <span class="comment">#进入解压目录</span></span><br><span class="line"><span class="variable">$ </span>python setup.py install <span class="comment">#编译安装</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#拷贝和修改默认配置文件的名称</span></span><br><span class="line"><span class="variable">$ </span>cd /usr/share/denyhosts/ <span class="comment">#进入安装目录</span></span><br><span class="line"><span class="variable">$ </span>cp denyhosts.cfg-dist denyhosts.cfg</span><br><span class="line"><span class="variable">$ </span>cp daemon-control-dist daemon-control</span><br></pre></td></tr></table></figure>

<h2 id="3-配置"><a href="#3-配置" class="headerlink" title="3. 配置"></a>3. 配置</h2><p>此配置为可选项，因为原本就已经有默认的配置了。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#3.编辑配置文件denyhosts.cfg</span></span><br><span class="line">$ vim denyhosts.cfg   <span class="comment">#该配置文件结构比较简单，如果不想瞎折腾可以参照如下配置即可：</span></span><br><span class="line"></span><br><span class="line">PURGE_DENY = 1d       <span class="comment">#ip被禁止之后，多久可以释放(w表示周，d表示天，h表示小时，m表示分钟)</span></span><br><span class="line">DENY_THRESHOLD_INVALID = 5 <span class="comment">#无效用户名限制登陆次数</span></span><br><span class="line">DENY_THRESHOLD_VALID = 10 <span class="comment">#有效用户名限制登陆次数</span></span><br><span class="line">DENY_THRESHOLD_ROOT = 5 <span class="comment">#root限制登陆次数</span></span><br><span class="line">AGE_RESET_ROOT = 1d  <span class="comment">#root用户登录失败计数归零的时间</span></span><br></pre></td></tr></table></figure>

<p>更多配置说明：</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">############ THESE SETTINGS ARE REQUIRED ############</span><br><span class="line">#sshd的日志文件</span><br><span class="line">SECURE_LOG = /var/log/secure </span><br><span class="line">#将阻止IP写入到hosts.deny,所以这个工具只支持 支持tcp wrapper的协议     </span><br><span class="line">HOSTS_DENY = /etc/hosts.deny </span><br><span class="line">#当一个IP被阻止以后，过多长时间被自动解禁。可选如<span class="number">3</span>m（三分钟）、<span class="number">5</span>h（<span class="number">5</span>小时）、<span class="number">2</span>d（两天）、<span class="number">8</span>w（<span class="number">8</span>周）、<span class="number">1</span>y(一年)</span><br><span class="line">PURGE_DENY = <span class="number">1</span>w </span><br><span class="line">#阻止服务名   </span><br><span class="line">BLOCK_SERVICE  = sshd</span><br><span class="line">#定义了某一IP最多被解封多少次。即某一IP由于暴力破解SSH密码被阻止/解封达到了PURGE_THRESHOLD次，则会被永久禁止；</span><br><span class="line">PURGE_THRESHOLD = <span class="number">20</span></span><br><span class="line">#允许无效用户登录失败的次数     </span><br><span class="line">DENY_THRESHOLD_INVALID = <span class="number">5</span></span><br><span class="line">#允许普通有效用户登录失败的次数   </span><br><span class="line">DENY_THRESHOLD_VALID = <span class="number">10</span>  </span><br><span class="line">#允许root登录失败的次数  </span><br><span class="line">DENY_THRESHOLD_ROOT = <span class="number">1</span>   </span><br><span class="line">#设定 deny host 写入到该资料夹   </span><br><span class="line">DENY_THRESHOLD_RESTRICTED = <span class="number">1</span></span><br><span class="line">#将deny的host或ip记录到work_dir中      </span><br><span class="line">WORK_DIR = /var/lib/denyhosts      </span><br><span class="line">SUSPICIOUS_LOGIN_REPORT_ALLOWED_HOSTS=YES</span><br><span class="line">#是否做域名反解   </span><br><span class="line">HOSTNAME_LOOKUP=YES  </span><br><span class="line">#将DenyHost启动的pid记录到LOCK_FILE中，已确保服务正确启动，防止同时启动多个服务  </span><br><span class="line">LOCK_FILE = /var/lock/subsys/denyhosts    </span><br><span class="line"></span><br><span class="line">############ THESE SETTINGS ARE OPTIONAL ############</span><br><span class="line">#设置管理员邮件地址 例如****@<span class="number">163.</span>com</span><br><span class="line">ADMIN_EMAIL = root</span><br><span class="line">SMTP_HOST = localhost</span><br><span class="line">SMTP_PORT = <span class="number">25</span></span><br><span class="line">SMTP_FROM = DenyHosts &lt;nobody@localhost&gt;</span><br><span class="line">SMTP_SUBJECT = DenyHosts Report <span class="keyword">from</span> $[HOSTNAME]</span><br><span class="line"></span><br><span class="line"># 有效用户登录失败计数归零的时间</span><br><span class="line">AGE_RESET_VALID=<span class="number">5</span>d  </span><br><span class="line"># ROOT用户登录失败计数归零的时间</span><br><span class="line">AGE_RESET_ROOT=<span class="number">25</span>d  </span><br><span class="line"># 用户的失败登录计数重置为<span class="number">0</span>的时间(/usr/share/denyhosts/restricted-usernames)</span><br><span class="line">AGE_RESET_RESTRICTED=<span class="number">25</span>d  </span><br><span class="line"># 无效用户登录失败计数归零的时间</span><br><span class="line">AGE_RESET_INVALID=<span class="number">10</span>d</span><br><span class="line"></span><br><span class="line">######### THESE SETTINGS ARE SPECIFIC TO DAEMON MODE  ##########</span><br><span class="line">#denyhost服务日志文件</span><br><span class="line">DAEMON_LOG = /var/log/denyhosts  </span><br><span class="line"></span><br><span class="line">DAEMON_SLEEP = <span class="number">30</span>s </span><br><span class="line">#该项与PURGE_DENY 设置成一样，也是清除hosts.deniedssh 用户的时间,区别是以daemon模式运行时跟PURGE_DENY配合使用，自动解禁才能生效</span><br><span class="line">DAEMON_PURGE = <span class="number">1</span>h</span><br></pre></td></tr></table></figure>

<h2 id="4-启动denyhosts"><a href="#4-启动denyhosts" class="headerlink" title="4.启动denyhosts"></a>4.启动denyhosts</h2><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$ ./daemon-control <span class="literal">start</span></span><br></pre></td></tr></table></figure>

<p>可以使用命令<code>ps -ef | grep denyhosts</code>查看是否运行成功。如下结果表示运行成功。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">[<span class="symbol">root@</span>host denyhosts]# ps -ef | grep denyhosts</span><br><span class="line">root     <span class="number">17588</span>     <span class="number">1</span>  <span class="number">0</span> <span class="number">11</span>:<span class="number">57</span> ?        <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> python /usr/bin/denyhosts.py --daemon --config=/usr/share/denyhosts/denyhosts.cfg</span><br><span class="line">root     <span class="number">17611</span> <span class="number">24100</span>  <span class="number">0</span> <span class="number">12</span>:<span class="number">07</span> pts/<span class="number">1</span>    <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> grep --color=<span class="built_in">auto</span> denyhosts</span><br><span class="line">[<span class="symbol">root@</span>host denyhosts]#</span><br></pre></td></tr></table></figure>

<h2 id="5-设置开机自动启动"><a href="#5-设置开机自动启动" class="headerlink" title="5.设置开机自动启动"></a>5.设置开机自动启动</h2><p>让<code>denyhosts</code>每次重启后自动启动。设置自动启动可以通过两种方法进行。</p>
<p>第一种是将<code>denyhosts</code>作为守护进程服务运行，这种方法可以通过<code>/etc/init.d/denyhosts</code>命令来控制其状态。方法如下：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ cd /etc/init.d</span><br><span class="line">$ ln -s /usr/share/denyhosts/daemon-control denyhosts</span><br><span class="line">$<span class="built_in"> service </span>denyhosts start</span><br></pre></td></tr></table></figure>

<p>或者用以下命令通过<code>chkconfig</code>工具来管理更方便。</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">cd</span> <span class="string">/etc/init.d</span></span><br><span class="line">$ chkconfig <span class="params">--add</span> denyhosts</span><br><span class="line">$ chkconfig <span class="params">--level</span> 2345 denyhosts on</span><br></pre></td></tr></table></figure>

<p>第二种是将<code>denyhosts</code>直接加入<code>rc.local</code>中自动启动（类似于<code>Windows</code>中的“启动文件夹”）：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>echo <span class="string">'/usr/share/denyhosts/daemon-control start'</span> &gt;&gt; <span class="regexp">/etc/rc</span>.local</span><br></pre></td></tr></table></figure>

<p>如果想查看已经被阻止的<code>IP</code>，查看<code>/etc/hosts.deny</code> 文件即可。如下：</p>
<figure class="highlight vala"><table><tr><td class="code"><pre><span class="line">[root@host ~]# cat /etc/hosts.deny</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># hosts.deny	This file contains access rules which are used to</span></span><br><span class="line"><span class="meta">#		deny connections to network services that either use</span></span><br><span class="line"><span class="meta">#		the tcp_wrappers library or that have been</span></span><br><span class="line"><span class="meta">#		started through a tcp_wrappers-enabled xinetd.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#		The rules in this file can also be set up in</span></span><br><span class="line"><span class="meta">#		/etc/hosts.allow with a 'deny' option instead.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#		See 'man 5 hosts_options' and 'man 5 hosts_access'</span></span><br><span class="line"><span class="meta">#		for information on rule syntax.</span></span><br><span class="line"><span class="meta">#		See 'man tcpd' for information on tcp_wrappers</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># DenyHosts: Sat Jan 12 12:22:17 2019 | sshd: 120.35.33.27</span></span><br><span class="line">sshd: <span class="number">120.35</span><span class="number">.33</span><span class="number">.27</span></span><br><span class="line">[root@host ~]#</span><br></pre></td></tr></table></figure>

<h2 id="6-解禁ip"><a href="#6-解禁ip" class="headerlink" title="6. 解禁ip"></a>6. 解禁ip</h2><p>编辑<code>/etc/hosts.deny</code>。然后删除或者注释掉对应的<code>sshd</code>即可。如以下用注释的方式解禁：</p>
<figure class="highlight vala"><table><tr><td class="code"><pre><span class="line">[root@host ~]# vim /etc/hosts.deny</span><br><span class="line"><span class="meta"># hosts.deny	This file contains access rules which are used to</span></span><br><span class="line"><span class="meta">#		deny connections to network services that either use</span></span><br><span class="line"><span class="meta">#		the tcp_wrappers library or that have been</span></span><br><span class="line"><span class="meta">#		started through a tcp_wrappers-enabled xinetd.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#		The rules in this file can also be set up in</span></span><br><span class="line"><span class="meta">#		/etc/hosts.allow with a 'deny' option instead.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#		See 'man 5 hosts_options' and 'man 5 hosts_access'</span></span><br><span class="line"><span class="meta">#		for information on rule syntax.</span></span><br><span class="line"><span class="meta">#		See 'man tcpd' for information on tcp_wrappers</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"># DenyHosts: Sat Jan 12 12:22:17 2019 | sshd: 120.35.33.27</span></span><br><span class="line"><span class="meta">#sshd: 120.35.33.27</span></span><br><span class="line">[root@host ~]#</span><br></pre></td></tr></table></figure>

<p>如果想删除一个已经禁止的主机IP,只在<code>/etc/hosts.deny</code>删除是没用的。需要进入<code>/usr/share/denyhosts/data/</code> 目录对以下文件一个个删除你想取消的主机IP才行。</p>
<blockquote>
<p>/usr/share/denyhosts/data/hosts<br>/usr/share/denyhosts/data/hosts-restricted<br>/usr/share/denyhosts/data/hosts-root<br>/usr/share/denyhosts/data/hosts-valid<br>/usr/share/denyhosts/data/users-hosts</p>
</blockquote>
<p>你可以执行命令<code>sudo grep 120.35.33.27 /usr/share/denyhosts/data/*</code>查看具体文件ip为“120.35.33.27”的具体位置</p>
<p>但如果这样一个有个操作确实很麻烦，不过机智的我在网上找了一个脚本(<code>denyhosts_removeip.sh</code>)，这个脚本可以快速的解决这个问题。其内容如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Author:licess</span></span><br><span class="line"><span class="comment"># Website:https://www.vpser.net &amp; https://lnmp.org</span></span><br><span class="line">HOST=<span class="variable">$1</span></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$&#123;HOST&#125;</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Usage:<span class="variable">$0</span> IP"</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Remove IP:<span class="variable">$&#123;HOST&#125;</span> from denyhosts..."</span></span><br><span class="line">/etc/init.d/denyhosts stop</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'</span></span><br><span class="line"><span class="string">/etc/hosts.deny</span></span><br><span class="line"><span class="string">/usr/share/denyhosts/data/hosts</span></span><br><span class="line"><span class="string">/usr/share/denyhosts/data/hosts-restricted</span></span><br><span class="line"><span class="string">/usr/share/denyhosts/data/hosts-root</span></span><br><span class="line"><span class="string">/usr/share/denyhosts/data/hosts-valid</span></span><br><span class="line"><span class="string">/usr/share/denyhosts/data/users-hosts</span></span><br><span class="line"><span class="string">'</span> | grep -v <span class="string">"^$"</span> | xargs sed -i <span class="string">"/<span class="variable">$&#123;HOST&#125;</span>/d"</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#iptables -D INPUT -s $&#123;HOST&#125; -p tcp -m tcp --dport 22 -j DROP</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">" done"</span></span><br><span class="line">/etc/init.d/denyhosts start</span><br></pre></td></tr></table></figure>

<p>执行脚本清除denyhosts某个IP的命令如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">bash</span> <span class="selector-tag">denyhosts_removeip</span><span class="selector-class">.sh</span> 10<span class="selector-class">.10</span><span class="selector-class">.10</span><span class="selector-class">.10</span></span><br></pre></td></tr></table></figure>

<p>参考教程：</p>
<ol>
<li><a href="http://coolnull.com/2068.html" target="_blank" rel="noopener">http://coolnull.com/2068.html</a></li>
<li><a href="https://www.spamcage.com/denyhosts.html" target="_blank" rel="noopener">https://www.spamcage.com/denyhosts.html</a></li>
</ol>
]]></content>
      <tags>
        <tag>Tech</tag>
      </tags>
  </entry>
</search>
